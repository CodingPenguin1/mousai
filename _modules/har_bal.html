
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>har_bal &#8212; Mousai 0.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for har_bal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Harmonic balance solvers and other related tools.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="c1"># import logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">fftp</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">newton_krylov</span><span class="p">,</span> <span class="n">anderson</span><span class="p">,</span> <span class="n">broyden1</span><span class="p">,</span> <span class="n">broyden2</span><span class="p">,</span> \
    <span class="n">excitingmixing</span><span class="p">,</span> <span class="n">linearmixing</span><span class="p">,</span> <span class="n">diagbroyden</span>


<span class="c1"># logging.basicConfig(level=print)</span>
<span class="c1"># Use `logging.debug` in place of print.</span>
<span class="c1"># for instance logging.debug(pformat(&#39;e {} X {}&#39;.format(e,X)))</span>

<span class="c1"># This will output only info and warnings</span>
<span class="c1"># logging.basicConfig(level=logging.INFO)</span>

<span class="c1"># This will output only warnings</span>
<span class="c1"># logging.basicConfig(level=logging.WARNING)</span>


<div class="viewcode-block" id="hb_time"><a class="viewcode-back" href="../reference/mousai.html#har_bal.hb_time">[docs]</a><span class="k">def</span> <span class="nf">hb_time</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton_krylov&#39;</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">num_variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eqform</span><span class="o">=</span><span class="s1">&#39;second_order&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{},</span> <span class="n">realify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Harmonic balance solver for first and second order ODEs.</span>

<span class="sd">    Obtains the solution of a first-order and second-order differential</span>
<span class="sd">    equation under the presumption that the solution is harmonic using an</span>
<span class="sd">    algebraic time method.</span>

<span class="sd">    Returns `t` (time), `x` (displacement), `v` (velocity), and `a`</span>
<span class="sd">    (acceleration) response of a first- or second- order linear ordinary</span>
<span class="sd">    differential equation defined by</span>
<span class="sd">    :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)` or</span>
<span class="sd">    :math:`\dot{\mathbf{x}}=f(\mathbf{x},\omega)`.</span>

<span class="sd">    For the state space form, the function `sdfunc` should have the form::</span>

<span class="sd">        def duff_osc_ss(x, params):  # params is a dictionary of parameters</span>
<span class="sd">            omega = params[&#39;omega&#39;]  # `omega` will be put into the dictionary</span>
<span class="sd">                                     # for you</span>
<span class="sd">            t = params[&#39;cur_time&#39;]   # The time value is available as</span>
<span class="sd">                                     # `cur_time` in the dictionary</span>
<span class="sd">            xdot = np.array([[x[1]],[-x[0]-.1*x[0]**3-.1*x[1]+1*sin(omega*t)]])</span>
<span class="sd">            return xdot</span>

<span class="sd">    In a state space form solution, the function must accept the states and the</span>
<span class="sd">    `params` dictionary. This dictionary should be used to obtain the</span>
<span class="sd">    prescribed response frequency and the current time. These plus any other</span>
<span class="sd">    parameters are used to calculate the state derivatives which are returned</span>
<span class="sd">    by the function.</span>

<span class="sd">    For the second order form the function `sdfunc` should have the form::</span>

<span class="sd">        def duff_osc(x, v, params):  # params is a dictionary of parameters</span>
<span class="sd">            omega = params[&#39;omega&#39;]  # `omega` will be put into the dictionary</span>
<span class="sd">                                     # for you</span>
<span class="sd">            t = params[&#39;cur_time&#39;]   # The time value is available as</span>
<span class="sd">                                     # `cur_time` in the dictionary</span>
<span class="sd">            return np.array([[-x-.1*x**3-.2*v+sin(omega*t)]])</span>

<span class="sd">    In a second-order form solution the function must take the states and the</span>
<span class="sd">    `params` dictionary. This dictionary should be used to obtain the</span>
<span class="sd">    prescribed response frequency and the current time. These plus any other</span>
<span class="sd">    parameters are used to calculate the state derivatives which are returned</span>
<span class="sd">    by the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        For `eqform=&#39;first_order&#39;`, name of function that returns **column</span>
<span class="sd">        vector** first derivative given `x`, and a dictionry of parameters.</span>
<span class="sd">        This is *NOT* a string (not the name of the function).</span>

<span class="sd">        :math:`\dot{\mathbf{x}}=f(\mathbf{x},\omega)`</span>

<span class="sd">        For `eqform=&#39;second_order&#39;`, name of function that returns **column</span>
<span class="sd">        vector** second derivative given `x`, `v`, and a dictionary of</span>
<span class="sd">        parameters. This is *NOT* a string.</span>

<span class="sd">        :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)`</span>
<span class="sd">    x0 : array_like, somewhat optional</span>
<span class="sd">        n x m array where n is the number of equations and m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">        It is required that :math:`m = 1 + 2 num_{harmonics}`. (we will</span>
<span class="sd">        generalize allowable default values later.)</span>
<span class="sd">    omega : float</span>
<span class="sd">        assumed fundamental response frequency in radians per second.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Name of optimization method to be used.</span>
<span class="sd">    num_harmonics : int, optional</span>
<span class="sd">        Number of harmonics to presume. The omega = 0 constant term is always</span>
<span class="sd">        presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1</span>
<span class="sd">        exceeds the number of columns of `x0` then `x0` will be expanded, using</span>
<span class="sd">        Fourier analaysis, to include additional harmonics with the starting</span>
<span class="sd">        presumption of zero values.</span>
<span class="sd">    num_variables : int, somewhat optional</span>
<span class="sd">        Number of states for a state space model, or number of generalized</span>
<span class="sd">        dispacements for a second order form.</span>
<span class="sd">        If `x0` is defined, num_variables is inferred. An error will result if</span>
<span class="sd">        both `x0` and num_variables are left out of the function call.</span>
<span class="sd">        `num_variables` must be defined if `x0` is not.</span>
<span class="sd">    eqform : str, optional</span>
<span class="sd">        `second_order` or `first_order`. (second order is default)</span>
<span class="sd">    params : dict, optional</span>
<span class="sd">        Dictionary of parameters needed by sdfunc.</span>
<span class="sd">    realify : boolean, optional</span>
<span class="sd">        Force the returned results to be real.</span>
<span class="sd">    other : any</span>
<span class="sd">        Other keyword arguments available to nonlinear solvers in</span>
<span class="sd">        `scipy.optimize.nonlin</span>
<span class="sd">        &lt;https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html&gt;`_.</span>
<span class="sd">        See `Notes`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t, x, e, amps, phases : array_like</span>
<span class="sd">        time, displacement history (time steps along columns), errors,</span>
<span class="sd">    amps : float array</span>
<span class="sd">        amplitudes of displacement (primary harmonic) in column vector format.</span>
<span class="sd">    phases : float array</span>
<span class="sd">        amplitudes of displacement (primary harmonic) in column vector format.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import mousai as ms</span>
<span class="sd">    &gt;&gt;&gt; t, x, e, amps, phases = ms.hb_time(ms.duff_osc,</span>
<span class="sd">    ...                                    np.array([[0,1,-1]]),</span>
<span class="sd">    ...                                    omega = 0.7)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso::</span>

<span class="sd">       ``hb_freq``</span>

<span class="sd">    This method is not reliable for a low number of harmonics.</span>

<span class="sd">    Calls a linear algebra function from</span>
<span class="sd">    `scipy.optimize.nonlin</span>
<span class="sd">    &lt;https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html&gt;`_ with</span>
<span class="sd">    `newton_krylov` as the default.</span>

<span class="sd">    Evaluates the differential equation/s at evenly spaced points in time. Each</span>
<span class="sd">    point in time yields a single equation. One harmonic plus the constant term</span>
<span class="sd">    results in 3 points in time over the cycle.</span>

<span class="sd">    Solver should gently &quot;walk&quot; solution up to get to nonlinearities for hard</span>
<span class="sd">    nonlinearities.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        1. calls `hb_err` with `x` as the variable to solve for.</span>
<span class="sd">        2. `hb_err` uses a Fourier representation of `x` to obtain</span>
<span class="sd">           velocities (after an inverse FFT) then calls `sdfunc` to determine</span>
<span class="sd">           accelerations.</span>
<span class="sd">        3. Accelerations are also obtained using a Fourier representation of x</span>
<span class="sd">        4. Error in the accelerations (or state derivatives) are the functional</span>
<span class="sd">           error used by the nonlinear algebraic solver</span>
<span class="sd">           (default `newton_krylov`) to be minimized by the solver.</span>

<span class="sd">    Options to the nonlinear solvers can be passed in by \*\*kwargs (keyword</span>
<span class="sd">    arguments) identical to those available to the nonlinear solver.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initial conditions exist?</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_variables</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: Must either define number of variables or initial</span><span class="se">\</span>
<span class="s1">                  guess for x.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
    <span class="k">elif</span> <span class="n">num_harmonics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_harmonics</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_harmonics</span> <span class="o">&gt;</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">x_freq</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">x_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">x_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x_freq</span><span class="p">,</span> <span class="p">[</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">x_zeros</span><span class="p">,</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">x_freq</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sdfunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">sdfunc</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sdfunc is expected to be a function name, not a string&quot;</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdfunc</span>  <span class="c1"># function that returns SO derivative</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">omega</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;n_har&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_harmonics</span>

    <span class="k">def</span> <span class="nf">hb_err</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Array (vector) of hamonic balance second order algebraic errors.</span>

<span class="sd">        Given a set of second order equations</span>
<span class="sd">        :math:`\ddot{x} = f(x, \dot{x}, \omega, t)`</span>
<span class="sd">        calculate the error :math:`E = \ddot{x} - f(x, \dot{x}, \omega, t)`</span>
<span class="sd">        presuming that :math:`x` can be represented as a Fourier series, and</span>
<span class="sd">        thus :math:`\dot{x}` and :math:`\ddot{x}` can be obtained from the</span>
<span class="sd">        Fourier series representation of :math:`x`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            x is an :math:`n \\times m` by 1 array of presumed displacements.</span>
<span class="sd">            It must be a &quot;list&quot; array (not a linear algebra vector). Here</span>
<span class="sd">            :math:`n` is the number of displacements and :math:`m` is the</span>
<span class="sd">            number of times per cycle at which the displacement is guessed</span>
<span class="sd">            (minimum of 3)</span>

<span class="sd">        params : dictionary</span>
<span class="sd">            Because this function will be called by one of the scipy.optimize</span>
<span class="sd">            root finders, it must be a function of only `x`. However, for</span>
<span class="sd">            generality it need to be built based on user defined variables.</span>
<span class="sd">            These variables must be in the scope of memory when the function is</span>
<span class="sd">            created. For conveience they are stored in the variable `params`.</span>

<span class="sd">                1. `function`: the function which returns the numerically</span>
<span class="sd">                calculated state derivatives (or second derivatives) given the</span>
<span class="sd">                states (or states and first derivatives).</span>

<span class="sd">                2. `omega`: which is the defined fundamental harmonic</span>
<span class="sd">                at which the solution is desired.</span>

<span class="sd">                3. `n_har`: an integer representing the number of harmonics.</span>
<span class="sd">                Note that `m` above is equal to 1 + 2 * `n_har`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        e : array_like</span>
<span class="sd">            2d array of numerical error of presumed solution(s) `x`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `function` and `omega` are not separately defined arguments so as to</span>
<span class="sd">        enable algebraic solver functions to call `hb_time_err` cleanly.</span>

<span class="sd">        The algorithm is broadly as follows:</span>
<span class="sd">            1. The velocity or accelerations are calculated in the same shape</span>
<span class="sd">               as `x` as the variables `vel` and `accel`, one column for each</span>
<span class="sd">               time step.</span>
<span class="sd">            3. Each column of `x` and `v` are sent with `t`, `omega`, and other</span>
<span class="sd">               `**kwargs** to `function` with the results</span>
<span class="sd">               agregated into the columns of `accel_num`.</span>
<span class="sd">            4. The difference between `accel_num` and `accel` or</span>
<span class="sd">               `velocity_num` and `velocity` represent the error used</span>
<span class="sd">               by the numerical algebraic equation solver.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">nonlocal</span> <span class="n">params</span>  <span class="c1"># Will stay out of global/conflicts</span>
        <span class="n">n_har</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;n_har&#39;</span><span class="p">]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_har</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eqform</span> <span class="o">==</span> <span class="s1">&#39;second_order&#39;</span><span class="p">:</span>
            <span class="n">accel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
            <span class="n">accel_from_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">accel</span><span class="p">)</span>

            <span class="c1"># Should subtract in place below to save memory for large problems</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># This should enable t to be used for current time in loops</span>
                <span class="c1"># might be able to be commented out, left as example</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># loops</span>
                <span class="c1"># Note that everything in params can be accessed within</span>
                <span class="c1"># `function`.</span>
                <span class="n">accel_from_deriv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">vel</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                                            <span class="n">params</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">accel_from_deriv</span> <span class="o">-</span> <span class="n">accel</span>
        <span class="k">elif</span> <span class="n">eqform</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>
            <span class="n">vel_from_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
            <span class="c1"># Should subtract in place below to save memory for large problems</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># This should enable t to be used for current time in loops</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Note that everything in params can be accessed within</span>
                <span class="c1"># `function`.</span>
                <span class="n">vel_from_deriv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span>\
                    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">e</span> <span class="o">=</span> <span class="n">vel_from_deriv</span> <span class="o">-</span> <span class="n">vel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eqform cannot have a value of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">eqform</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">method</span><span class="p">](</span><span class="n">hb_err</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>  <span class="c1"># np.full([x0.shape[0],x0.shape[1]],np.nan)</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">hb_err</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># np.full([x0.shape[0],x0.shape[1]],np.nan)</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xhar</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xhar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">xhar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">hb_err</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">realify</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x was real&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span></div>


<div class="viewcode-block" id="hb_freq"><a class="viewcode-back" href="../reference/mousai.html#har_bal.hb_freq">[docs]</a><span class="k">def</span> <span class="nf">hb_freq</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton_krylov&#39;</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">num_variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eqform</span><span class="o">=</span><span class="s1">&#39;second_order&#39;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">{},</span> <span class="n">realify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_time_steps</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Harmonic balance solver for first and second order ODEs.</span>

<span class="sd">    Obtains the solution of a first-order and second-order differential</span>
<span class="sd">    equation under the presumption that the solution is harmonic using an</span>
<span class="sd">    algebraic time method.</span>

<span class="sd">    Returns `t` (time), `x` (displacement), `v` (velocity), and `a`</span>
<span class="sd">    (acceleration) response of a first or second order linear ordinary</span>
<span class="sd">    differential equation defined by</span>
<span class="sd">    :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)` or</span>
<span class="sd">    :math:`\dot{\mathbf{x}}=f(\mathbf{x},\omega)`.</span>

<span class="sd">    For the state space form, the function `sdfunc` should have the form::</span>

<span class="sd">        def duff_osc_ss(x, params):  # params is a dictionary of parameters</span>
<span class="sd">            omega = params[&#39;omega&#39;]  # `omega` will be put into the dictionary</span>
<span class="sd">                                     # for you</span>
<span class="sd">            t = params[&#39;cur_time&#39;]   # The time value is available as</span>
<span class="sd">                                     # `cur_time` in the dictionary</span>
<span class="sd">            x_dot = np.array([[x[1]],</span>
<span class="sd">                              [-x[0]-.1*x[0]**3-.1*x[1]+1*sin(omega*t)]])</span>
<span class="sd">            return x_dot</span>

<span class="sd">    In a state space form solution, the function must take the states and the</span>
<span class="sd">    `params` dictionary. This dictionary should be used to obtain the</span>
<span class="sd">    prescribed response frequency and the current time. These plus any other</span>
<span class="sd">    parameters are used to calculate the state derivatives which are returned</span>
<span class="sd">    by the function.</span>

<span class="sd">    For the second order form the function `sdfunc` should have the form::</span>

<span class="sd">        def duff_osc(x, v, params):  # params is a dictionary of parameters</span>
<span class="sd">            omega = params[&#39;omega&#39;]  # `omega` will be put into the dictionary</span>
<span class="sd">                                     # for you</span>
<span class="sd">            t = params[&#39;cur_time&#39;]   # The time value is available as</span>
<span class="sd">                                     # `cur_time` in the dictionary</span>
<span class="sd">            return np.array([[-x-.1*x**3-.2*v+sin(omega*t)]])</span>

<span class="sd">    In a second-order form solution the function must take the states and the</span>
<span class="sd">    `params` dictionary. This dictionary should be used to obtain the</span>
<span class="sd">    prescribed response frequency and the current time. These plus any other</span>
<span class="sd">    parameters are used to calculate the state derivatives which are returned</span>
<span class="sd">    by the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        For `eqform=&#39;first_order&#39;`, name of function that returns **column</span>
<span class="sd">        vector** first derivative given `x`, and a dictionry of parameters.</span>
<span class="sd">        This is *NOT* a string (not the name of the function).</span>

<span class="sd">        :math:`\dot{\mathbf{x}}=f(\mathbf{x},\omega)`</span>

<span class="sd">        For `eqform=&#39;second_order&#39;`, name of function that returns **column</span>
<span class="sd">        vector** second derivative given `x`, `v`, `omega` and \*\*kwargs. This</span>
<span class="sd">        is *NOT* a string.</span>

<span class="sd">        :math:`\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)`</span>
<span class="sd">    x0 : array_like, somewhat optional</span>
<span class="sd">        n x m array where n is the number of equations and m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">        It is required that :math:`m = 1 + 2 num_{harmonics}`. (we will</span>
<span class="sd">        generalize allowable default values later.)</span>
<span class="sd">    omega : float</span>
<span class="sd">        assumed fundamental response frequency in radians per second.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Name of optimization method to be used.</span>
<span class="sd">    num_harmonics : int, optional</span>
<span class="sd">        Number of harmonics to presume. The `omega` = 0 constant term is always</span>
<span class="sd">        presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1</span>
<span class="sd">        exceeds the number of columns of `x0` then `x0` will be expanded, using</span>
<span class="sd">        Fourier analaysis, to include additional harmonics with the starting</span>
<span class="sd">        presumption of zero values.</span>
<span class="sd">    num_variables : int, somewhat optional</span>
<span class="sd">        Number of states for a state space model, or number of generalized</span>
<span class="sd">        dispacements for a second order form.</span>
<span class="sd">        If `x0` is defined, num_variables is inferred. An error will result if</span>
<span class="sd">        both `x0` and num_variables are left out of the function call.</span>
<span class="sd">        `num_variables` must be defined if `x0` is not.</span>
<span class="sd">    eqform : str, optional</span>
<span class="sd">        `second_order` or `first_order`. (`second order` is default)</span>
<span class="sd">    params : dict, optional</span>
<span class="sd">        Dictionary of parameters needed by sdfunc.</span>
<span class="sd">    realify : boolean, optional</span>
<span class="sd">        Force the returned results to be real.</span>
<span class="sd">    mask_constant : boolean, optional</span>
<span class="sd">        Force the constant term of the series representation to be zero.</span>
<span class="sd">    num_time_steps : int, default = 51</span>
<span class="sd">        number of time steps to use in time histories for derivative</span>
<span class="sd">        calculations.</span>
<span class="sd">    other : any</span>
<span class="sd">        Other keyword arguments available to nonlinear solvers in</span>
<span class="sd">        `scipy.optimize.nonlin</span>
<span class="sd">        &lt;https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html&gt;`_.</span>
<span class="sd">        See Notes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t, x, e, amps, phases : array_like</span>
<span class="sd">        time, displacement history (time steps along columns), errors,</span>
<span class="sd">    amps : float array</span>
<span class="sd">        amplitudes of displacement (primary harmonic) in column vector format.</span>
<span class="sd">    phases : float array</span>
<span class="sd">        amplitudes of displacement (primary harmonic) in column vector format.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import mousai as ms</span>
<span class="sd">    &gt;&gt;&gt; t, x, e, amps, phases = ms.hb_freq(ms.duff_osc,</span>
<span class="sd">    ...                                    np.array([[0,1,-1]]),</span>
<span class="sd">    ...                                    omega = 0.7)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso::</span>

<span class="sd">       `hb_time`</span>

<span class="sd">    Calls a linear algebra function from</span>
<span class="sd">    `scipy.optimize.nonlin</span>
<span class="sd">    &lt;https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html&gt;`_ with</span>
<span class="sd">    `newton_krylov` as the default.</span>

<span class="sd">    Evaluates the differential equation/s at evenly spaced points in time</span>
<span class="sd">    defined by the user (default 51). Uses error in FFT of derivative</span>
<span class="sd">    (acceeration or state equations) calculated based on:</span>

<span class="sd">    1. governing equations</span>
<span class="sd">    2. derivative of `x` (second derivative for state method)</span>

<span class="sd">    Solver should gently &quot;walk&quot; solution up to get to nonlinearities for hard</span>
<span class="sd">    nonlinearities.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        1. calls `hb_time_err` with x as the variable to solve for.</span>
<span class="sd">        2. `hb_time_err` uses a Fourier representation of x to obtain</span>
<span class="sd">           velocities (after an inverse FFT) then calls `sdfunc` to determine</span>
<span class="sd">           accelerations.</span>
<span class="sd">        3. Accelerations are also obtained using a Fourier representation of x</span>
<span class="sd">        4. Error in the accelerations (or state derivatives) are the functional</span>
<span class="sd">           error used by the nonlinear algebraic solver</span>
<span class="sd">           (default `newton_krylov`) to be minimized by the solver.</span>

<span class="sd">    Options to the nonlinear solvers can be passed in by \*\*kwargs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initial conditions exist?</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_variables</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: Must either define number of variables or initial</span><span class="se">\</span>
<span class="s1">                  guess for x.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
    <span class="k">elif</span> <span class="n">num_harmonics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_harmonics</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_harmonics</span> <span class="o">&gt;</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">x_freq</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">x_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">x_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x_freq</span><span class="p">,</span> <span class="p">[</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">x_zeros</span><span class="p">,</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">x_freq</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_harmonics</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sdfunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">sdfunc</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sdfunc is expected to be a function name, not a string&quot;</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdfunc</span>  <span class="c1"># function that returns SO derivative</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">omega</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;n_har&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_harmonics</span>

    <span class="n">X0</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask_constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">X0</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;mask_constant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_constant</span>

    <span class="k">def</span> <span class="nf">hb_err</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return errors in equation eval versus derivative calculation.&quot;&quot;&quot;</span>
        <span class="c1"># r&quot;&quot;&quot;Array (vector) of hamonic balance second order algebraic errors.</span>
        <span class="c1">#</span>
        <span class="c1"># Given a set of second order equations</span>
        <span class="c1"># :math:`\ddot{x} = f(x, \dot{x}, \omega, t)`</span>
        <span class="c1"># calculate the error :math:`E = \mathcal{F}(\ddot{x}</span>
        <span class="c1"># - \mathcal{F}\left(f(x, \dot{x}, \omega, t)\right)`</span>
        <span class="c1"># presuming that :math:`x` can be represented as a Fourier series, and</span>
        <span class="c1"># thus :math:`\dot{x}` and :math:`\ddot{x}` can be obtained from the</span>
        <span class="c1"># Fourier series representation of :math:`x` and :math:`\mathcal{F}(x)`</span>
        <span class="c1"># represents the Fourier series of :math:`x(t)`</span>
        <span class="c1">#</span>
        <span class="c1"># Parameters</span>
        <span class="c1"># ----------</span>
        <span class="c1"># X : float array</span>
        <span class="c1">#     X is an :math:`n \\times m` by 1 array of sp.fft.rfft</span>
        <span class="c1">#     fft coefficients lacking the constant (first) element.</span>
        <span class="c1">#     Here :math:`n` is the number of displacements and :math:`m` 2</span>
        <span class="c1">#     times the number of harmonics to be solved for.</span>
        <span class="c1">#</span>
        <span class="c1"># **kwargs : string, float, variable</span>
        <span class="c1">#     **kwargs is a packed set of keyword arguments with 3 required</span>
        <span class="c1">#     arguments.</span>
        <span class="c1">#         1. `function`: a string name of the function which returned</span>
        <span class="c1">#         the numerically calculated acceleration.</span>
        <span class="c1">#</span>
        <span class="c1">#         2. `omega`: which is the defined fundamental harmonic</span>
        <span class="c1">#         at which the is desired.</span>
        <span class="c1">#</span>
        <span class="c1">#         3. `n_har`: an integer representing the number of harmonics.</span>
        <span class="c1">#         Note that `m` above is equal to 2 * `n_har`.</span>
        <span class="c1">#</span>
        <span class="c1"># Returns</span>
        <span class="c1"># -------</span>
        <span class="c1"># e : float array</span>
        <span class="c1">#     2d array of numerical errors of presumed solution(s) `X`. Error</span>
        <span class="c1">#     between first (or second) derivative via Fourier analysis and via</span>
        <span class="c1">#     solution of the governing equation.</span>
        <span class="c1">#</span>
        <span class="c1"># Notes</span>
        <span class="c1"># -----</span>
        <span class="c1"># `function` and `omega` are not separately defined arguments so as to</span>
        <span class="c1"># enable algebraic solver functions to call `hb_err` cleanly.</span>
        <span class="c1">#</span>
        <span class="c1"># The algorithm is as follows:</span>
        <span class="c1">#     1. X is prepended with a zero vector (to represent the constant</span>
        <span class="c1">#        value)</span>
        <span class="c1">#     2. `x` is calculated via an inverse `numpy.fft.rfft`</span>
        <span class="c1">#     1. The velocity and accelerations are calculated in the same</span>
        <span class="c1">#        shape as `x` as `vel` and `accel`.</span>
        <span class="c1">#     3. Each column of `x` and `v` are sent with `t`, `omega`, and</span>
        <span class="c1">#        other `**kwargs** to `function` one at a time with the results</span>
        <span class="c1">#        agregated into the columns of `accel_num`.</span>
        <span class="c1">#     4. The rfft is taken of `accel_num` and `accel`.</span>
        <span class="c1">#     5. The first column is stripped out of both `accel_num_freq and</span>
        <span class="c1">#        `accel_freq`.</span>

        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="k">nonlocal</span> <span class="n">params</span>  <span class="c1"># Will stay out of global/conflicts</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="n">mask_constant</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;mask_constant&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask_constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">time_e</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">time_history</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="n">num_time_steps</span><span class="p">)</span>

        <span class="n">vel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">num_time_steps</span>

        <span class="k">if</span> <span class="n">eqform</span> <span class="o">==</span> <span class="s1">&#39;second_order&#39;</span><span class="p">:</span>
            <span class="n">accel</span> <span class="o">=</span> <span class="n">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
            <span class="n">accel_from_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">accel</span><span class="p">)</span>

            <span class="c1"># Should subtract in place below to save memory for large problems</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># This should enable t to be used for current time in loops</span>
                <span class="c1"># might be able to be commented out, left as example</span>
                <span class="c1"># t = time_e[i]</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># loops</span>
                <span class="c1"># Note that everything in params can be accessed within</span>
                <span class="c1"># `function`.</span>
                <span class="n">accel_from_deriv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">vel</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                                            <span class="n">params</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">accel_from_deriv</span> <span class="o">-</span> <span class="n">accel</span><span class="p">)</span>  <span class="c1"># /np.max(np.abs(accel))</span>

            <span class="n">states</span> <span class="o">=</span> <span class="n">accel</span>

        <span class="k">elif</span> <span class="n">eqform</span> <span class="o">==</span> <span class="s1">&#39;first_order&#39;</span><span class="p">:</span>

            <span class="n">vel_from_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
            <span class="c1"># Should subtract in place below to save memory for large problems</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># This should enable t to be used for current time in loops</span>
                <span class="c1"># t = time_e[i]</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Note that everything in params can be accessed within</span>
                <span class="c1"># `function`.</span>
                <span class="n">vel_from_deriv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span>\
                    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">vel_from_deriv</span> <span class="o">-</span> <span class="n">vel</span><span class="p">)</span>  <span class="c1"># /np.max(np.abs(vel))</span>

            <span class="n">states</span> <span class="o">=</span> <span class="n">vel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eqform cannot have a value of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">eqform</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">states_fft</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="n">e_fft</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="n">states_fft_condensed</span> <span class="o">=</span> <span class="n">condense_rfft</span><span class="p">(</span><span class="n">states_fft</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">)</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">condense_rfft</span><span class="p">(</span><span class="n">e_fft</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask_constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">states_fft_condensed</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">method</span><span class="p">](</span><span class="n">hb_err</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">hb_err</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask_constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">except</span><span class="p">:</span>  <span class="c1"># Catches and raises errors- needs actual error listed.</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;Excepted- search failed for omega = </span><span class="si">{:6.4f}</span><span class="s1"> rad/s.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">omega</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;What ever error this is, please put into har_bal</span>
<span class="s2">               after the excepts (2 of them)&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X0</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mask_constant</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">hb_err</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask_constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="k">raise</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">realify</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x was real&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span></div>


<div class="viewcode-block" id="hb_so"><a class="viewcode-back" href="../reference/mousai.html#har_bal.hb_so">[docs]</a><span class="k">def</span> <span class="nf">hb_so</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deprecated function name. Use hb_time.&quot;&quot;&quot;</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;hb_so is deprecated. Please use hb_time or an alternative.&#39;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hb_time</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="harmonic_deriv"><a class="viewcode-back" href="../reference/mousai.html#har_bal.harmonic_deriv">[docs]</a><span class="k">def</span> <span class="nf">harmonic_deriv</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return derivative of a harmonic function using frequency methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    omega: float</span>
<span class="sd">        Fundamendal frequency, in rad/sec, of repeating signal</span>
<span class="sd">    r: array_like</span>
<span class="sd">        | Array of rows of time histories to take the derivative of.</span>
<span class="sd">        | The 1 axis (each row) corresponds to a time history.</span>
<span class="sd">        | The length of the time histories *must be an odd integer*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s: array_like</span>
<span class="sd">        Function derivatives.</span>
<span class="sd">        The 1 axis (each row) corresponds to a time history.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from mousai import *</span>
<span class="sd">    &gt;&gt;&gt; import scipy as sp</span>
<span class="sd">    &gt;&gt;&gt; from scipy import pi, sin, cos</span>
<span class="sd">    &gt;&gt;&gt; f = 2</span>
<span class="sd">    &gt;&gt;&gt; omega = 2.*pi * f</span>
<span class="sd">    &gt;&gt;&gt; numsteps = 11</span>
<span class="sd">    &gt;&gt;&gt; t = sp.arange(0,1/omega*2*pi,1/omega*2*pi/numsteps)</span>
<span class="sd">    &gt;&gt;&gt; x = sp.array([sin(omega*t)])</span>
<span class="sd">    &gt;&gt;&gt; v = sp.array([omega*cos(omega*t)])</span>
<span class="sd">    &gt;&gt;&gt; states = sp.append(x,v,axis = 0)</span>
<span class="sd">    &gt;&gt;&gt; state_derives = harmonic_deriv(omega,states)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t,states.T,t,state_derives.T,&#39;x&#39;)</span>
<span class="sd">    [&lt;matplotlib.line...]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="n">omega</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="solmf"><a class="viewcode-back" href="../reference/mousai.html#har_bal.solmf">[docs]</a><span class="k">def</span> <span class="nf">solmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return acceleration of second order linear matrix system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, v, F : array_like</span>
<span class="sd">        :math:`n\times 1` arrays of current displacement, velocity, and Force.</span>
<span class="sd">    M, C, K : array_like</span>
<span class="sd">        Mass, damping, and stiffness matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        :math:`n\\times 1` acceleration vector</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[2,0],[0,1]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[2,-1],[-1,3]])</span>
<span class="sd">    &gt;&gt;&gt; C = 0.01 * M + 0.01 * K</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1],[0]])</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([[0],[10]])</span>
<span class="sd">    &gt;&gt;&gt; F = v * 0.1</span>
<span class="sd">    &gt;&gt;&gt; a = solmf(x, v, M, C, K, F)</span>
<span class="sd">    &gt;&gt;&gt; print(a)</span>
<span class="sd">        [[-0.95]</span>
<span class="sd">         [ 1.6 ]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span> <span class="o">@</span> <span class="n">v</span> <span class="o">+</span> <span class="n">K</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span></div>


<div class="viewcode-block" id="duff_osc"><a class="viewcode-back" href="../reference/mousai.html#har_bal.duff_osc">[docs]</a><span class="k">def</span> <span class="nf">duff_osc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Duffing oscillator acceleration.&quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>
    <span class="n">acceleration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">x</span> <span class="o">-</span> <span class="o">.</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mf">3.</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">t</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">acceleration</span></div>


<div class="viewcode-block" id="time_history"><a class="viewcode-back" href="../reference/mousai.html#har_bal.time_history">[docs]</a><span class="k">def</span> <span class="nf">time_history</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">realify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate refined time history from harmonic balance solution.</span>

<span class="sd">    Harmonic balance solutions presume a limited number of harmonics in the</span>
<span class="sd">    solution. The result is that the time history is usually a very limited</span>
<span class="sd">    number of values. Plotting these results implies that the solution isn&#39;t</span>
<span class="sd">    actually a continuous one. This function fills in the gaps using the</span>
<span class="sd">    harmonics obtained in the solution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t: array_like</span>
<span class="sd">        1 x m array where m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">    x: array_like</span>
<span class="sd">        n x m array where m is the number of equations and m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">    realify: boolean</span>
<span class="sd">        Force the returned results to be real.</span>
<span class="sd">    num_time_points: int</span>
<span class="sd">        number of points desired in the &quot;smooth&quot; time history.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t: array_like</span>
<span class="sd">        1 x num_time_points array.</span>
<span class="sd">    x: array_like</span>
<span class="sd">        n x num_time_points array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mousai as ms</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[-0.34996499,  1.36053998, -1.11828552]])</span>
<span class="sd">    &gt;&gt;&gt; t = np.array([0.        , 2.991993  , 5.98398601])</span>
<span class="sd">    &gt;&gt;&gt; t_full, x_full = ms.time_history(t, x, num_time_points=300)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The implication of this function is that the higher harmonics that</span>
<span class="sd">    were not determined in the solution are zero. This is indeed the assumption</span>
<span class="sd">    made when setting up the harmonic balance solution. Whether this is a valid</span>
<span class="sd">    assumption is something that the user must judge when obtaining the</span>
<span class="sd">    solution.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t_length</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_length</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_time_points</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">x_freq</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">x_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x_freq</span><span class="p">,</span> <span class="p">[</span><span class="n">t_length</span> <span class="o">-</span> <span class="n">t_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">x_zeros</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">x_freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_time_points</span> <span class="o">/</span> <span class="n">t_length</span>
    <span class="k">if</span> <span class="n">realify</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x was real&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span></div>


<div class="viewcode-block" id="condense_fft"><a class="viewcode-back" href="../reference/mousai.html#har_bal.condense_fft">[docs]</a><span class="k">def</span> <span class="nf">condense_fft</span><span class="p">(</span><span class="n">X_full</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create equivalent amplitude reduced-size FFT from longer FFT.&quot;&quot;&quot;</span>
    <span class="n">X_red</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X_full</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:(</span><span class="n">num_harmonics</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                        <span class="n">X_full</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="n">num_harmonics</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
             <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_harmonics</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">X_full</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_red</span></div>


<div class="viewcode-block" id="condense_rfft"><a class="viewcode-back" href="../reference/mousai.html#har_bal.condense_rfft">[docs]</a><span class="k">def</span> <span class="nf">condense_rfft</span><span class="p">(</span><span class="n">X_full</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return real fft with fewer harmonics.&quot;&quot;&quot;</span>
    <span class="n">X_len</span> <span class="o">=</span> <span class="n">X_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">X_red</span> <span class="o">=</span> <span class="n">X_full</span><span class="p">[:,</span> <span class="p">:(</span><span class="n">num_harmonics</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> \
        <span class="n">X_len</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_harmonics</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_red</span></div>


<div class="viewcode-block" id="expand_rfft"><a class="viewcode-back" href="../reference/mousai.html#har_bal.expand_rfft">[docs]</a><span class="k">def</span> <span class="nf">expand_rfft</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">num_harmonics</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return real fft with mor harmonics.&quot;&quot;&quot;</span>
    <span class="n">X_len</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cur_num_harmonics</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">X_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span> <span class="o">/</span> <span class="n">X_len</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_harmonics</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_harmonics</span>
                                               <span class="o">-</span> <span class="n">cur_num_harmonics</span><span class="p">))))</span>
                            <span class="p">))</span>
    <span class="k">return</span> <span class="n">X_expanded</span></div>


<div class="viewcode-block" id="rfft_to_fft"><a class="viewcode-back" href="../reference/mousai.html#har_bal.rfft_to_fft">[docs]</a><span class="k">def</span> <span class="nf">rfft_to_fft</span><span class="p">(</span><span class="n">X_real</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Switch from SciPy real fft form to complex fft form.&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fftp</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">X_real</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">X</span></div>


<div class="viewcode-block" id="fft_to_rfft"><a class="viewcode-back" href="../reference/mousai.html#har_bal.fft_to_rfft">[docs]</a><span class="k">def</span> <span class="nf">fft_to_rfft</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Switch from complex form fft form to SciPy rfft form.&quot;&quot;&quot;</span>
    <span class="n">X_real</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">X_real</span></div>


<div class="viewcode-block" id="time_history_r"><a class="viewcode-back" href="../reference/mousai.html#har_bal.time_history_r">[docs]</a><span class="k">def</span> <span class="nf">time_history_r</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">realify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate refined time history from harmonic balance solution.</span>

<span class="sd">    Harmonic balance solutions presume a limited number of harmonics in the</span>
<span class="sd">    solution. The result is that the time history is usually a very limited</span>
<span class="sd">    number of values. Plotting these results implies that the solution isn&#39;t</span>
<span class="sd">    actually a continuous one. This function fills in the gaps using the</span>
<span class="sd">    harmonics obtained in the solution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t: array_like</span>
<span class="sd">        1 x m array where m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">    x: array_like</span>
<span class="sd">        n x m array where m is the number of equations and m is the number of</span>
<span class="sd">        values representing the repeating solution.</span>
<span class="sd">    realify: boolean</span>
<span class="sd">        Force the returned results to be real.</span>
<span class="sd">    num_time_points: int</span>
<span class="sd">        number of points desired in the &quot;smooth&quot; time history.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t: array_like</span>
<span class="sd">        1 x num_time_points array.</span>
<span class="sd">    x: array_like</span>
<span class="sd">        n x num_time_points array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import mousai as ms</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[-0.34996499,  1.36053998, -1.11828552]])</span>
<span class="sd">    &gt;&gt;&gt; t = np.array([0.        , 2.991993  , 5.98398601])</span>
<span class="sd">    &gt;&gt;&gt; t_full, x_full = ms.time_history(t, x, num_time_points=300)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The implication of this function is that the higher harmonics that</span>
<span class="sd">    were not determined in the solution are zero. This is indeed the assumption</span>
<span class="sd">    made when setting up the harmonic balance solution. Whether this is a valid</span>
<span class="sd">    assumption is something that the user must judge when obtaining the</span>
<span class="sd">    solution.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t_length</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_length</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_time_points</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">x_freq</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_zeros</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">x_freq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x_freq</span><span class="p">,</span> <span class="p">[</span><span class="n">t_length</span> <span class="o">-</span> <span class="n">t_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">x_zeros</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># print(x_freq)</span>
    <span class="c1"># x_freq = np.hstack((x_freq, x_zeros))</span>
    <span class="c1"># print(x_freq)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">fftp</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">x_freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_time_points</span> <span class="o">/</span> <span class="n">t_length</span>
    <span class="k">if</span> <span class="n">realify</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x was real&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span></div>


<div class="viewcode-block" id="function_to_mousai"><a class="viewcode-back" href="../reference/mousai.html#har_bal.function_to_mousai">[docs]</a><span class="k">def</span> <span class="nf">function_to_mousai</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert scipy.integrate functions to Mousai form.</span>

<span class="sd">    The form of the function returning state derivatives is</span>
<span class="sd">    `sdfunc(x, t, params)` where `x` are the current states as an `n` by `1`</span>
<span class="sd">    array, `t` is a scalar, and `params` is a dictionary of parameters, one of</span>
<span class="sd">    which must be `omega`. This is inconsistent with the SciPy numerical</span>
<span class="sd">    integrators for good cause, but can make simultaneous usage diffucult.</span>

<span class="sd">    This function returns a function compatible with Mousai by using the</span>
<span class="sd">    inspect package to determine the form of the function being used and to</span>
<span class="sd">    wrap it in Mousai form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        function in SciPy integrator form (`odeint`_ or `solve_ivp`_)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_function : function</span>
<span class="sd">        function in Mousai form (accepting inputs like a standard Mousai</span>
<span class="sd">        function)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso::</span>

<span class="sd">       * ``old_mousai_to_new_mousai``</span>
<span class="sd">       * ``mousai_to_odeint``</span>
<span class="sd">       * ``mousai_to_solve_ivp``</span>

<span class="sd">    .. _`odeint` : https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html#scipy.integrate.ode</span>
<span class="sd">    .. _`solve_ivp` : https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">)</span>

    <span class="n">call_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">call_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">call_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="s1">&#39;t&#39;</span> <span class="ow">or</span> <span class="n">call_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="c1"># t and x must be swapped, params available in over-scope</span>
            <span class="k">def</span> <span class="nf">newfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{}):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">exec</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># params available in overscope</span>
            <span class="k">def</span> <span class="nf">newfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{}):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">exec</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">call_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="s1">&#39;t&#39;</span> <span class="ow">or</span> <span class="n">call_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="c1"># t and x must be swapped, params available in over-scope</span>
            <span class="k">def</span> <span class="nf">newfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{}):</span>
                <span class="n">other_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">call_parameters</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># params available in overscope</span>
            <span class="k">def</span> <span class="nf">newfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{}):</span>
                <span class="n">other_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">call_parameters</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfunction</span></div>


<div class="viewcode-block" id="old_mousai_to_new_mousai"><a class="viewcode-back" href="../reference/mousai.html#har_bal.old_mousai_to_new_mousai">[docs]</a><span class="k">def</span> <span class="nf">old_mousai_to_new_mousai</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return derivative function converted to new Mousai format.</span>

<span class="sd">    The original format for the Mousai derivative function was</span>
<span class="sd">    `sdfunc(x, params)`. This is inconsistent with the SciPy integration</span>
<span class="sd">    functions. To act more as expected, the standard from 0.4.0 on will take</span>
<span class="sd">    the form `sdfunc(x, t, params)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        function in old Mousai form. `sdfunc(y, params)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_sdfunc : function</span>
<span class="sd">        function in new Mousai form. `sdfunc(y, t, params)`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso::</span>

<span class="sd">       * ``function_to_mousai``</span>
<span class="sd">       * ``mousai_to_odeint``</span>
<span class="sd">       * ``mousai_to_solve_ivp``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">new_sdfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_sdfunc</span></div>


<div class="viewcode-block" id="mousai_to_solve_ivp"><a class="viewcode-back" href="../reference/mousai.html#har_bal.mousai_to_solve_ivp">[docs]</a><span class="k">def</span> <span class="nf">mousai_to_solve_ivp</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return function callable from solve_ivp given Mousai sdfunc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        Mousai-style function returning state derivatives.</span>
<span class="sd">    params : dictionary</span>
<span class="sd">        dictionary of parameters used by `sdfunc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    solve_ivp_function : function</span>
<span class="sd">        function ordered to work with `solve_ivp`_</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ability to pass parameters was deprecated in the new SciPy integrators:</span>
<span class="sd">    `https://stackoverflow.com/questions/48245765/pass-args-for-solve-ivp-new-scipy-ode-api`</span>
<span class="sd">    `https://github.com/scipy/scipy/issues/8352`</span>

<span class="sd">    .. seealso::</span>

<span class="sd">       * ``function_to_mousai``</span>
<span class="sd">       * ``old_mousai_to_new_mousai``</span>
<span class="sd">       * ``mousai_to_odeint``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">)</span>

    <span class="n">call_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">call_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sdfunc</span> <span class="o">=</span> <span class="n">old_mousai_to_new_mousai</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Warning. The two-argument form of Mousai derivsative functions</span>
<span class="s2">                 is deprecated.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solve_ivp_function</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">solve_ivp_function</span></div>


<div class="viewcode-block" id="mousai_to_odeint"><a class="viewcode-back" href="../reference/mousai.html#har_bal.mousai_to_odeint">[docs]</a><span class="k">def</span> <span class="nf">mousai_to_odeint</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return function callable from solve_ivp given Mousai a sdfunc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdfunc : function</span>
<span class="sd">        Mousai-style function returning state derivatives.</span>
<span class="sd">    params : dictionary</span>
<span class="sd">        dictionary of parameters used by `sdfunc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    odeint_function : function</span>
<span class="sd">        function ordered to work with `odeint`_</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso::</span>

<span class="sd">       * ``function_to_mousai``</span>
<span class="sd">       * ``old_mousai_to_new_mousai``</span>
<span class="sd">       * ``mousai_to_solve_ivp``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">)</span>

    <span class="n">call_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">call_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sdfunc</span> <span class="o">=</span> <span class="n">old_mousai_to_new_mousai</span><span class="p">(</span><span class="n">sdfunc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Warning. The two-argument form of Mousai derivative ⁠⁠</span><span class="se">\</span>
<span class="s2">                 functions is deprecated.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;sdfunc_params&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Define your parameters in the user created `sdfunc_params`&quot;</span><span class="p">,</span>
              <span class="s2">&quot;dictionary.&quot;</span><span class="p">)</span>
        <span class="n">sdfunc_params</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">odeint_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sdfunc</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">sdfunc_params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">odeint_function</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Mousai</a></h1>



<p class="blurb">Harmonic Balance Solvers</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Joseph C. Slater.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-62100376-5']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Harmonic Balance Tools (mousai.har_bal) &#8212; Mousai 0.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Revision History" href="revision_history.html" />
    <link rel="prev" title="Reference" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="harmonic-balance-tools-mousai-har-bal">
<h1>Harmonic Balance Tools (<code class="xref py py-mod docutils literal notranslate"><span class="pre">mousai.har_bal</span></code>)<a class="headerlink" href="#harmonic-balance-tools-mousai-har-bal" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-har_bal"></span><p>Harmonic balance solvers and other related tools.</p>
<dl class="function">
<dt id="har_bal.condense_fft">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">condense_fft</code><span class="sig-paren">(</span><em class="sig-param">X_full</em>, <em class="sig-param">num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#condense_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.condense_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Create equivalent amplitude reduced-size FFT from longer FFT.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.condense_rfft">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">condense_rfft</code><span class="sig-paren">(</span><em class="sig-param">X_full</em>, <em class="sig-param">num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#condense_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.condense_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real fft with fewer harmonics.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.duff_osc">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">duff_osc</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">v</em>, <em class="sig-param">params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#duff_osc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.duff_osc" title="Permalink to this definition">¶</a></dt>
<dd><p>Duffing oscillator acceleration.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.expand_rfft">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">expand_rfft</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#expand_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.expand_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real fft with mor harmonics.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.fft_to_rfft">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">fft_to_rfft</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#fft_to_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.fft_to_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch from complex form fft form to SciPy rfft form.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.function_to_mousai">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">function_to_mousai</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#function_to_mousai"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.function_to_mousai" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert scipy.integrate functions to Mousai form.</p>
<p>The form of the function returning state derivatives is
<cite>sdfunc(x, t, params)</cite> where <cite>x</cite> are the current states as an <cite>n</cite> by <cite>1</cite>
array, <cite>t</cite> is a scalar, and <cite>params</cite> is a dictionary of parameters, one of
which must be <cite>omega</cite>. This is inconsistent with the SciPy numerical
integrators for good cause, but can make simultaneous usage diffucult.</p>
<p>This function returns a function compatible with Mousai by using the
inspect package to determine the form of the function being used and to
wrap it in Mousai form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>function in SciPy integrator form (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html#scipy.integrate.ode">odeint</a> or <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp">solve_ivp</a>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_function</strong><span class="classifier">function</span></dt><dd><p>function in Mousai form (accepting inputs like a standard Mousai
function)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">old_mousai_to_new_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_odeint</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_solve_ivp</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.harmonic_deriv">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">harmonic_deriv</code><span class="sig-paren">(</span><em class="sig-param">omega</em>, <em class="sig-param">r</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#harmonic_deriv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.harmonic_deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return derivative of a harmonic function using frequency methods.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>omega: float</strong></dt><dd><p>Fundamendal frequency, in rad/sec, of repeating signal</p>
</dd>
<dt><strong>r: array_like</strong></dt><dd><div class="line-block">
<div class="line">Array of rows of time histories to take the derivative of.</div>
<div class="line">The 1 axis (each row) corresponds to a time history.</div>
<div class="line">The length of the time histories <em>must be an odd integer</em>.</div>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>s: array_like</dt><dd><p>Function derivatives.
The 1 axis (each row) corresponds to a time history.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>(<a class="reference external" href="../reference/mousai-1.py">Source code</a>, <a class="reference external" href="../reference/mousai-1.png">png</a>, <a class="reference external" href="../reference/mousai-1.hires.png">hires.png</a>, <a class="reference external" href="../reference/mousai-1.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="../_images/mousai-1.png" src="../_images/mousai-1.png" />
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_freq">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">hb_freq</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">omega=1</em>, <em class="sig-param">method='newton_krylov'</em>, <em class="sig-param">num_harmonics=1</em>, <em class="sig-param">num_variables=None</em>, <em class="sig-param">mask_constant=True</em>, <em class="sig-param">eqform='second_order'</em>, <em class="sig-param">params={}</em>, <em class="sig-param">realify=True</em>, <em class="sig-param">num_time_steps=51</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonic balance solver for first and second order ODEs.</p>
<p>Obtains the solution of a first-order and second-order differential
equation under the presumption that the solution is harmonic using an
algebraic time method.</p>
<p>Returns <cite>t</cite> (time), <cite>x</cite> (displacement), <cite>v</cite> (velocity), and <cite>a</cite>
(acceleration) response of a first or second order linear ordinary
differential equation defined by
<span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span> or
<span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span>.</p>
<p>For the state space form, the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc_ss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="n">x_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">x_dot</span>
</pre></div>
</div>
<p>In a state space form solution, the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<p>For the second order form the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">x</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
</pre></div>
</div>
<p>In a second-order form solution the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>For <cite>eqform=’first_order’</cite>, name of function that returns <strong>column
vector</strong> first derivative given <cite>x</cite>, and a dictionry of parameters.
This is <em>NOT</em> a string (not the name of the function).</p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span></p>
<p>For <cite>eqform=’second_order’</cite>, name of function that returns <strong>column
vector</strong> second derivative given <cite>x</cite>, <cite>v</cite>, <cite>omega</cite> and **kwargs. This
is <em>NOT</em> a string.</p>
<p><span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span></p>
</dd>
<dt><strong>x0</strong><span class="classifier">array_like, somewhat optional</span></dt><dd><p>n x m array where n is the number of equations and m is the number of
values representing the repeating solution.
It is required that <span class="math notranslate nohighlight">\(m = 1 + 2 num_{harmonics}\)</span>. (we will
generalize allowable default values later.)</p>
</dd>
<dt><strong>omega</strong><span class="classifier">float</span></dt><dd><p>assumed fundamental response frequency in radians per second.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>Name of optimization method to be used.</p>
</dd>
<dt><strong>num_harmonics</strong><span class="classifier">int, optional</span></dt><dd><p>Number of harmonics to presume. The <cite>omega</cite> = 0 constant term is always
presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1
exceeds the number of columns of <cite>x0</cite> then <cite>x0</cite> will be expanded, using
Fourier analaysis, to include additional harmonics with the starting
presumption of zero values.</p>
</dd>
<dt><strong>num_variables</strong><span class="classifier">int, somewhat optional</span></dt><dd><p>Number of states for a state space model, or number of generalized
dispacements for a second order form.
If <cite>x0</cite> is defined, num_variables is inferred. An error will result if
both <cite>x0</cite> and num_variables are left out of the function call.
<cite>num_variables</cite> must be defined if <cite>x0</cite> is not.</p>
</dd>
<dt><strong>eqform</strong><span class="classifier">str, optional</span></dt><dd><p><cite>second_order</cite> or <cite>first_order</cite>. (<cite>second order</cite> is default)</p>
</dd>
<dt><strong>params</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of parameters needed by sdfunc.</p>
</dd>
<dt><strong>realify</strong><span class="classifier">boolean, optional</span></dt><dd><p>Force the returned results to be real.</p>
</dd>
<dt><strong>mask_constant</strong><span class="classifier">boolean, optional</span></dt><dd><p>Force the constant term of the series representation to be zero.</p>
</dd>
<dt><strong>num_time_steps</strong><span class="classifier">int, default = 51</span></dt><dd><p>number of time steps to use in time histories for derivative
calculations.</p>
</dd>
<dt><strong>other</strong><span class="classifier">any</span></dt><dd><p>Other keyword arguments available to nonlinear solvers in
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a>.
See Notes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t, x, e, amps, phases</strong><span class="classifier">array_like</span></dt><dd><p>time, displacement history (time steps along columns), errors,</p>
</dd>
<dt><strong>amps</strong><span class="classifier">float array</span></dt><dd><p>amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
<dt><strong>phases</strong><span class="classifier">float array</span></dt><dd><p>amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><cite>hb_time</cite></p>
</div>
<p>Calls a linear algebra function from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a> with
<cite>newton_krylov</cite> as the default.</p>
<p>Evaluates the differential equation/s at evenly spaced points in time
defined by the user (default 51). Uses error in FFT of derivative
(acceeration or state equations) calculated based on:</p>
<ol class="arabic simple">
<li><p>governing equations</p></li>
<li><p>derivative of <cite>x</cite> (second derivative for state method)</p></li>
</ol>
<p>Solver should gently “walk” solution up to get to nonlinearities for hard
nonlinearities.</p>
<dl class="simple">
<dt>Algorithm:</dt><dd><ol class="arabic simple">
<li><p>calls <cite>hb_time_err</cite> with x as the variable to solve for.</p></li>
<li><p><cite>hb_time_err</cite> uses a Fourier representation of x to obtain
velocities (after an inverse FFT) then calls <cite>sdfunc</cite> to determine
accelerations.</p></li>
<li><p>Accelerations are also obtained using a Fourier representation of x</p></li>
<li><p>Error in the accelerations (or state derivatives) are the functional
error used by the nonlinear algebraic solver
(default <cite>newton_krylov</cite>) to be minimized by the solver.</p></li>
</ol>
</dd>
</dl>
<p>Options to the nonlinear solvers can be passed in by **kwargs.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">hb_freq</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">duff_osc</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>                                   <span class="n">omega</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_so">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">hb_so</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_so"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_so" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated function name. Use hb_time.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_time">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">hb_time</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">omega=1</em>, <em class="sig-param">method='newton_krylov'</em>, <em class="sig-param">num_harmonics=1</em>, <em class="sig-param">num_variables=None</em>, <em class="sig-param">eqform='second_order'</em>, <em class="sig-param">params={}</em>, <em class="sig-param">realify=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonic balance solver for first and second order ODEs.</p>
<p>Obtains the solution of a first-order and second-order differential
equation under the presumption that the solution is harmonic using an
algebraic time method.</p>
<p>Returns <cite>t</cite> (time), <cite>x</cite> (displacement), <cite>v</cite> (velocity), and <cite>a</cite>
(acceleration) response of a first- or second- order linear ordinary
differential equation defined by
<span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span> or
<span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span>.</p>
<p>For the state space form, the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc_ss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="n">xdot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">xdot</span>
</pre></div>
</div>
<p>In a state space form solution, the function must accept the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<p>For the second order form the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">x</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
</pre></div>
</div>
<p>In a second-order form solution the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>For <cite>eqform=’first_order’</cite>, name of function that returns <strong>column
vector</strong> first derivative given <cite>x</cite>, and a dictionry of parameters.
This is <em>NOT</em> a string (not the name of the function).</p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span></p>
<p>For <cite>eqform=’second_order’</cite>, name of function that returns <strong>column
vector</strong> second derivative given <cite>x</cite>, <cite>v</cite>, and a dictionary of
parameters. This is <em>NOT</em> a string.</p>
<p><span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span></p>
</dd>
<dt><strong>x0</strong><span class="classifier">array_like, somewhat optional</span></dt><dd><p>n x m array where n is the number of equations and m is the number of
values representing the repeating solution.
It is required that <span class="math notranslate nohighlight">\(m = 1 + 2 num_{harmonics}\)</span>. (we will
generalize allowable default values later.)</p>
</dd>
<dt><strong>omega</strong><span class="classifier">float</span></dt><dd><p>assumed fundamental response frequency in radians per second.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>Name of optimization method to be used.</p>
</dd>
<dt><strong>num_harmonics</strong><span class="classifier">int, optional</span></dt><dd><p>Number of harmonics to presume. The omega = 0 constant term is always
presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1
exceeds the number of columns of <cite>x0</cite> then <cite>x0</cite> will be expanded, using
Fourier analaysis, to include additional harmonics with the starting
presumption of zero values.</p>
</dd>
<dt><strong>num_variables</strong><span class="classifier">int, somewhat optional</span></dt><dd><p>Number of states for a state space model, or number of generalized
dispacements for a second order form.
If <cite>x0</cite> is defined, num_variables is inferred. An error will result if
both <cite>x0</cite> and num_variables are left out of the function call.
<cite>num_variables</cite> must be defined if <cite>x0</cite> is not.</p>
</dd>
<dt><strong>eqform</strong><span class="classifier">str, optional</span></dt><dd><p><cite>second_order</cite> or <cite>first_order</cite>. (second order is default)</p>
</dd>
<dt><strong>params</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of parameters needed by sdfunc.</p>
</dd>
<dt><strong>realify</strong><span class="classifier">boolean, optional</span></dt><dd><p>Force the returned results to be real.</p>
</dd>
<dt><strong>other</strong><span class="classifier">any</span></dt><dd><p>Other keyword arguments available to nonlinear solvers in
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a>.
See <cite>Notes</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t, x, e, amps, phases</strong><span class="classifier">array_like</span></dt><dd><p>time, displacement history (time steps along columns), errors,</p>
</dd>
<dt><strong>amps</strong><span class="classifier">float array</span></dt><dd><p>amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
<dt><strong>phases</strong><span class="classifier">float array</span></dt><dd><p>amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">hb_freq</span></code></p>
</div>
<p>This method is not reliable for a low number of harmonics.</p>
<p>Calls a linear algebra function from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a> with
<cite>newton_krylov</cite> as the default.</p>
<p>Evaluates the differential equation/s at evenly spaced points in time. Each
point in time yields a single equation. One harmonic plus the constant term
results in 3 points in time over the cycle.</p>
<p>Solver should gently “walk” solution up to get to nonlinearities for hard
nonlinearities.</p>
<dl class="simple">
<dt>Algorithm:</dt><dd><ol class="arabic simple">
<li><p>calls <cite>hb_err</cite> with <cite>x</cite> as the variable to solve for.</p></li>
<li><p><cite>hb_err</cite> uses a Fourier representation of <cite>x</cite> to obtain
velocities (after an inverse FFT) then calls <cite>sdfunc</cite> to determine
accelerations.</p></li>
<li><p>Accelerations are also obtained using a Fourier representation of x</p></li>
<li><p>Error in the accelerations (or state derivatives) are the functional
error used by the nonlinear algebraic solver
(default <cite>newton_krylov</cite>) to be minimized by the solver.</p></li>
</ol>
</dd>
</dl>
<p>Options to the nonlinear solvers can be passed in by **kwargs (keyword
arguments) identical to those available to the nonlinear solver.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">hb_time</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">duff_osc</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>                                   <span class="n">omega</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.mousai_to_odeint">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">mousai_to_odeint</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em>, <em class="sig-param">params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#mousai_to_odeint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.mousai_to_odeint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return function callable from solve_ivp given Mousai a sdfunc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>Mousai-style function returning state derivatives.</p>
</dd>
<dt><strong>params</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary of parameters used by <cite>sdfunc</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>odeint_function</strong><span class="classifier">function</span></dt><dd><p>function ordered to work with <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html#scipy.integrate.ode">odeint</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function_to_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">old_mousai_to_new_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_solve_ivp</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.mousai_to_solve_ivp">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">mousai_to_solve_ivp</code><span class="sig-paren">(</span><em class="sig-param">sdfunc</em>, <em class="sig-param">params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#mousai_to_solve_ivp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.mousai_to_solve_ivp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return function callable from solve_ivp given Mousai sdfunc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>Mousai-style function returning state derivatives.</p>
</dd>
<dt><strong>params</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary of parameters used by <cite>sdfunc</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>solve_ivp_function</strong><span class="classifier">function</span></dt><dd><p>function ordered to work with <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp">solve_ivp</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ability to pass parameters was deprecated in the new SciPy integrators:
<cite>https://stackoverflow.com/questions/48245765/pass-args-for-solve-ivp-new-scipy-ode-api</cite>
<cite>https://github.com/scipy/scipy/issues/8352</cite></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function_to_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">old_mousai_to_new_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_odeint</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.old_mousai_to_new_mousai">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">old_mousai_to_new_mousai</code><span class="sig-paren">(</span><em class="sig-param">function</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#old_mousai_to_new_mousai"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.old_mousai_to_new_mousai" title="Permalink to this definition">¶</a></dt>
<dd><p>Return derivative function converted to new Mousai format.</p>
<p>The original format for the Mousai derivative function was
<cite>sdfunc(x, params)</cite>. This is inconsistent with the SciPy integration
functions. To act more as expected, the standard from 0.4.0 on will take
the form <cite>sdfunc(x, t, params)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sdfunc</strong><span class="classifier">function</span></dt><dd><p>function in old Mousai form. <cite>sdfunc(y, params)</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_sdfunc</strong><span class="classifier">function</span></dt><dd><p>function in new Mousai form. <cite>sdfunc(y, t, params)</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function_to_mousai</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_odeint</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mousai_to_solve_ivp</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.rfft_to_fft">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">rfft_to_fft</code><span class="sig-paren">(</span><em class="sig-param">X_real</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#rfft_to_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.rfft_to_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch from SciPy real fft form to complex fft form.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.solmf">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">solmf</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">v</em>, <em class="sig-param">M</em>, <em class="sig-param">C</em>, <em class="sig-param">K</em>, <em class="sig-param">F</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#solmf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.solmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return acceleration of second order linear matrix system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, v, F</strong><span class="classifier">array_like</span></dt><dd><p><span class="math notranslate nohighlight">\(n\times 1\)</span> arrays of current displacement, velocity, and Force.</p>
</dd>
<dt><strong>M, C, K</strong><span class="classifier">array_like</span></dt><dd><p>Mass, damping, and stiffness matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p><span class="math notranslate nohighlight">\(n\\times 1\)</span> acceleration vector</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">solmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">    [[-0.95]</span>
<span class="go">     [ 1.6 ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.time_history">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">time_history</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">x</em>, <em class="sig-param">num_time_points=200</em>, <em class="sig-param">realify=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#time_history"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.time_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate refined time history from harmonic balance solution.</p>
<p>Harmonic balance solutions presume a limited number of harmonics in the
solution. The result is that the time history is usually a very limited
number of values. Plotting these results implies that the solution isn’t
actually a continuous one. This function fills in the gaps using the
harmonics obtained in the solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t: array_like</strong></dt><dd><p>1 x m array where m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>x: array_like</strong></dt><dd><p>n x m array where m is the number of equations and m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>realify: boolean</strong></dt><dd><p>Force the returned results to be real.</p>
</dd>
<dt><strong>num_time_points: int</strong></dt><dd><p>number of points desired in the “smooth” time history.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>t: array_like</dt><dd><p>1 x num_time_points array.</p>
</dd>
<dt>x: array_like</dt><dd><p>n x num_time_points array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The implication of this function is that the higher harmonics that
were not determined in the solution are zero. This is indeed the assumption
made when setting up the harmonic balance solution. Whether this is a valid
assumption is something that the user must judge when obtaining the
solution.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.34996499</span><span class="p">,</span>  <span class="mf">1.36053998</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11828552</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.991993</span>  <span class="p">,</span> <span class="mf">5.98398601</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_full</span><span class="p">,</span> <span class="n">x_full</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">time_history</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.time_history_r">
<code class="sig-prename descclassname">har_bal.</code><code class="sig-name descname">time_history_r</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">x</em>, <em class="sig-param">num_time_points=200</em>, <em class="sig-param">realify=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#time_history_r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.time_history_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate refined time history from harmonic balance solution.</p>
<p>Harmonic balance solutions presume a limited number of harmonics in the
solution. The result is that the time history is usually a very limited
number of values. Plotting these results implies that the solution isn’t
actually a continuous one. This function fills in the gaps using the
harmonics obtained in the solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t: array_like</strong></dt><dd><p>1 x m array where m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>x: array_like</strong></dt><dd><p>n x m array where m is the number of equations and m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>realify: boolean</strong></dt><dd><p>Force the returned results to be real.</p>
</dd>
<dt><strong>num_time_points: int</strong></dt><dd><p>number of points desired in the “smooth” time history.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>t: array_like</dt><dd><p>1 x num_time_points array.</p>
</dd>
<dt>x: array_like</dt><dd><p>n x num_time_points array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The implication of this function is that the higher harmonics that
were not determined in the solution are zero. This is indeed the assumption
made when setting up the harmonic balance solution. Whether this is a valid
assumption is something that the user must judge when obtaining the
solution.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.34996499</span><span class="p">,</span>  <span class="mf">1.36053998</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11828552</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.991993</span>  <span class="p">,</span> <span class="mf">5.98398601</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_full</span><span class="p">,</span> <span class="n">x_full</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">time_history</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Mousai</a></h1>



<p class="blurb">Harmonic Balance Solvers</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Reference</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/mousai.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Joseph C. Slater.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/reference/mousai.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-62100376-5']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>
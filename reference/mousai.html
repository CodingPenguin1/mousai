
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Harmonic Balance Tools (mousai.har_bal) &#8212; Mousai 0.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Revision History" href="revision_history.html" />
    <link rel="prev" title="Reference" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="harmonic-balance-tools-mousai-har-bal">
<h1>Harmonic Balance Tools (<code class="xref py py-mod docutils literal notranslate"><span class="pre">mousai.har_bal</span></code>)<a class="headerlink" href="#harmonic-balance-tools-mousai-har-bal" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-har_bal"></span><p>Harmonic balance solvers and other related tools.</p>
<dl class="function">
<dt id="har_bal.condense_fft">
<code class="descclassname">har_bal.</code><code class="descname">condense_fft</code><span class="sig-paren">(</span><em>X_full</em>, <em>num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#condense_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.condense_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Create equivalent amplitude reduced-size FFT from longer FFT.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.condense_rfft">
<code class="descclassname">har_bal.</code><code class="descname">condense_rfft</code><span class="sig-paren">(</span><em>X_full</em>, <em>num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#condense_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.condense_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real fft with fewer harmonics.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.duff_osc">
<code class="descclassname">har_bal.</code><code class="descname">duff_osc</code><span class="sig-paren">(</span><em>x</em>, <em>v</em>, <em>params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#duff_osc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.duff_osc" title="Permalink to this definition">¶</a></dt>
<dd><p>Duffing oscillator acceleration.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.expand_rfft">
<code class="descclassname">har_bal.</code><code class="descname">expand_rfft</code><span class="sig-paren">(</span><em>X</em>, <em>num_harmonics</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#expand_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.expand_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real fft with mor harmonics.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.fft_to_rfft">
<code class="descclassname">har_bal.</code><code class="descname">fft_to_rfft</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#fft_to_rfft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.fft_to_rfft" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch from complex form fft form to SciPy rfft form.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.harmonic_deriv">
<code class="descclassname">har_bal.</code><code class="descname">harmonic_deriv</code><span class="sig-paren">(</span><em>omega</em>, <em>r</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#harmonic_deriv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.harmonic_deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return derivative of a harmonic function using frequency methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>omega: float</strong></dt>
<dd><p class="first last">Fundamendal frequency, in rad/sec, of repeating signal</p>
</dd>
<dt><strong>r: array_like</strong></dt>
<dd><div class="first last line-block">
<div class="line">Array of rows of time histories to take the derivative of.</div>
<div class="line">The 1 axis (each row) corresponds to a time history.</div>
<div class="line">The length of the time histories <em>must be an odd integer</em>.</div>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s: array_like</strong></dt>
<dd><p class="first last">Function derivatives.
The 1 axis (each row) corresponds to a time history.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>(<a class="reference external" href="../reference/mousai-1.py">Source code</a>, <a class="reference external" href="../reference/mousai-1.png">png</a>, <a class="reference external" href="../reference/mousai-1.hires.png">hires.png</a>, <a class="reference external" href="../reference/mousai-1.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/mousai-1.png" src="../_images/mousai-1.png" />
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_freq">
<code class="descclassname">har_bal.</code><code class="descname">hb_freq</code><span class="sig-paren">(</span><em>sdfunc</em>, <em>x0=None</em>, <em>omega=1</em>, <em>method='newton_krylov'</em>, <em>num_harmonics=1</em>, <em>num_variables=None</em>, <em>mask_constant=True</em>, <em>eqform='second_order'</em>, <em>params={}</em>, <em>realify=True</em>, <em>num_time_steps=51</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonic balance solver for first and second order ODEs.</p>
<p>Obtains the solution of a first-order and second-order differential
equation under the presumption that the solution is harmonic using an
algebraic time method.</p>
<p>Returns <cite>t</cite> (time), <cite>x</cite> (displacement), <cite>v</cite> (velocity), and <cite>a</cite>
(acceleration) response of a first or second order linear ordinary
differential equation defined by
<span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span> or
<span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span>.</p>
<p>For the state space form, the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc_ss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="n">x_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">xdot</span>
</pre></div>
</div>
<p>In a state space form solution, the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<p>For the second order form the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">x</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
</pre></div>
</div>
<p>In a second-order form solution the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sdfunc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first">For <cite>eqform=’first_order’</cite>, name of function that returns <strong>column
vector</strong> first derivative given <cite>x</cite>, <cite>omega</cite> and **kwargs. This is
<em>NOT</em> a string.</p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span></p>
<p>For <cite>eqform=’second_order’</cite>, name of function that returns <strong>column
vector</strong> second derivative given <cite>x</cite>, <cite>v</cite>, <cite>omega</cite> and **kwargs. This
is <em>NOT</em> a string.</p>
<p class="last"><span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span></p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, somewhat optional</span></dt>
<dd><p class="first last">n x m array where n is the number of equations and m is the number of
values representing the repeating solution.
It is required that <span class="math notranslate nohighlight">\(m = 1 + 2 num_{harmonics}\)</span>. (we will
generalize allowable default values later.)</p>
</dd>
<dt><strong>omega</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">assumed fundamental response frequency in radians per second.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of optimization method to be used.</p>
</dd>
<dt><strong>num_harmonics</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of harmonics to presume. The <cite>omega</cite> = 0 constant term is always
presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1
exceeds the number of columns of <cite>x0</cite> then <cite>x0</cite> will be expanded, using
Fourier analaysis, to include additional harmonics with the starting
presumption of zero values.</p>
</dd>
<dt><strong>num_variables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, somewhat optional</span></dt>
<dd><p class="first last">Number of states for a state space model, or number of generalized
dispacements for a second order form.
If <cite>x0</cite> is defined, num_variables is inferred. An error will result if
both <cite>x0</cite> and num_variables are left out of the function call.
<cite>num_variables</cite> must be defined if <cite>x0</cite> is not.</p>
</dd>
<dt><strong>eqform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last"><cite>second_order</cite> or <cite>first_order</cite>. (<cite>second order</cite> is default)</p>
</dd>
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionary of parameters needed by sdfunc.</p>
</dd>
<dt><strong>realify</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Force the returned results to be real.</p>
</dd>
<dt><strong>mask_constant</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Force the constant term of the series representation to be zero.</p>
</dd>
<dt><strong>num_time_steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default = 51</span></dt>
<dd><p class="first last">number of time steps to use in time histories for derivative
calculations.</p>
</dd>
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd><p class="first last">Other keyword arguments available to nonlinear solvers in
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a>.
See Notes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t, x, e, amps, phases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">time, displacement history (time steps along columns), errors,</p>
</dd>
<dt><strong>amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
<dt><strong>phases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><cite>hb_time</cite></p>
</div>
<p>Calls a linear algebra function from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a> with
<cite>newton_krylov</cite> as the default.</p>
<p>Evaluates the differential equation/s at evenly spaced points in time
defined by the user (default 51). Uses error in FFT of derivative
(acceeration or state equations) calculated based on:</p>
<ol class="arabic simple">
<li>governing equations</li>
<li>derivative of <cite>x</cite> (second derivative for state method)</li>
</ol>
<p>Solver should gently “walk” solution up to get to nonlinearities for hard
nonlinearities.</p>
<dl class="docutils">
<dt>Algorithm:</dt>
<dd><ol class="first last arabic simple">
<li>calls <cite>hb_time_err</cite> with x as the variable to solve for.</li>
<li><cite>hb_time_err</cite> uses a Fourier representation of x to obtain
velocities (after an inverse FFT) then calls <cite>sdfunc</cite> to determine
accelerations.</li>
<li>Accelerations are also obtained using a Fourier representation of x</li>
<li>Error in the accelerations (or state derivatives) are the functional
error used by the nonlinear algebraic solver
(default <cite>newton_krylov</cite>) to be minimized by the solver.</li>
</ol>
</dd>
</dl>
<p>Options to the nonlinear solvers can be passed in by **kwargs.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">hb_freq</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">duff_osc</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>                                   <span class="n">omega</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_so">
<code class="descclassname">har_bal.</code><code class="descname">hb_so</code><span class="sig-paren">(</span><em>sdfunc</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_so"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_so" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated function name. Use hb_time.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.hb_time">
<code class="descclassname">har_bal.</code><code class="descname">hb_time</code><span class="sig-paren">(</span><em>sdfunc</em>, <em>x0=None</em>, <em>omega=1</em>, <em>method='newton_krylov'</em>, <em>num_harmonics=1</em>, <em>num_variables=None</em>, <em>eqform='second_order'</em>, <em>params={}</em>, <em>realify=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#hb_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.hb_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Harmonic balance solver for first and second order ODEs.</p>
<p>Obtains the solution of a first-order and second-order differential
equation under the presumption that the solution is harmonic using an
algebraic time method.</p>
<p>Returns <cite>t</cite> (time), <cite>x</cite> (displacement), <cite>v</cite> (velocity), and <cite>a</cite>
(acceleration) response of a first- or second- order linear ordinary
differential equation defined by
<span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span> or
<span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span>.</p>
<p>For the state space form, the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc_ss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="n">xdot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">xdot</span>
</pre></div>
</div>
<p>In a state space form solution, the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<p>For the second order form the function <cite>sdfunc</cite> should have the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duff_osc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>  <span class="c1"># params is a dictionary of parameters</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>  <span class="c1"># `omega` will be put into the dictionary</span>
                             <span class="c1"># for you</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cur_time&#39;</span><span class="p">]</span>   <span class="c1"># The time value is available as</span>
                             <span class="c1"># `cur_time` in the dictionary</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">x</span><span class="o">-.</span><span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">-.</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]])</span>
</pre></div>
</div>
<p>In a second-order form solution the function must take the states and the
<cite>params</cite> dictionary. This dictionary should be used to obtain the
prescribed response frequency and the current time. These plus any other
parameters are used to calculate the state derivatives which are returned
by the function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sdfunc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first">For <cite>eqform=’first_order’</cite>, name of function that returns <strong>column
vector</strong> first derivative given <cite>x</cite>, <cite>omega</cite> and **kwargs. This is
<em>NOT</em> a string.</p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}}=f(\mathbf{x},\omega)\)</span></p>
<p>For <cite>eqform=’second_order’</cite>, name of function that returns <strong>column
vector</strong> second derivative given <cite>x</cite>, <cite>v</cite>, <cite>omega</cite> and **kwargs. This
is <em>NOT</em> a string.</p>
<p class="last"><span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}=f(\mathbf{x},\mathbf{v},\omega)\)</span></p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, somewhat optional</span></dt>
<dd><p class="first last">n x m array where n is the number of equations and m is the number of
values representing the repeating solution.
It is required that <span class="math notranslate nohighlight">\(m = 1 + 2 num_{harmonics}\)</span>. (we will
generalize allowable default values later.)</p>
</dd>
<dt><strong>omega</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">assumed fundamental response frequency in radians per second.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of optimization method to be used.</p>
</dd>
<dt><strong>num_harmonics</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of harmonics to presume. The omega = 0 constant term is always
presumed to exist. Minimum (and default) is 1. If num_harmonics*2+1
exceeds the number of columns of <cite>x0</cite> then <cite>x0</cite> will be expanded, using
Fourier analaysis, to include additional harmonics with the starting
presumption of zero values.</p>
</dd>
<dt><strong>num_variables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, somewhat optional</span></dt>
<dd><p class="first last">Number of states for a state space model, or number of generalized
dispacements for a second order form.
If <cite>x0</cite> is defined, num_variables is inferred. An error will result if
both <cite>x0</cite> and num_variables are left out of the function call.
<cite>num_variables</cite> must be defined if <cite>x0</cite> is not.</p>
</dd>
<dt><strong>eqform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last"><cite>second_order</cite> or <cite>first_order</cite>. (second order is default)</p>
</dd>
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionary of parameters needed by sdfunc.</p>
</dd>
<dt><strong>realify</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Force the returned results to be real.</p>
</dd>
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd><p class="first last">Other keyword arguments available to nonlinear solvers in
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a>.
See <cite>Notes</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t, x, e, amps, phases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">time, displacement history (time steps along columns), errors,</p>
</dd>
<dt><strong>amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
<dt><strong>phases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">amplitudes of displacement (primary harmonic) in column vector format.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">hb_freq</span></code></p>
</div>
<p>This method is not reliable for a low number of harmonics.</p>
<p>Calls a linear algebra function from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html">scipy.optimize.nonlin</a> with
<cite>newton_krylov</cite> as the default.</p>
<p>Evaluates the differential equation/s at evenly spaced points in time. Each
point in time yields a single equation. One harmonic plus the constant term
results in 3 points in time over the cycle.</p>
<p>Solver should gently “walk” solution up to get to nonlinearities for hard
nonlinearities.</p>
<dl class="docutils">
<dt>Algorithm:</dt>
<dd><ol class="first last arabic simple">
<li>calls <cite>hb_err</cite> with <cite>x</cite> as the variable to solve for.</li>
<li><cite>hb_err</cite> uses a Fourier representation of <cite>x</cite> to obtain
velocities (after an inverse FFT) then calls <cite>sdfunc</cite> to determine
accelerations.</li>
<li>Accelerations are also obtained using a Fourier representation of x</li>
<li>Error in the accelerations (or state derivatives) are the functional
error used by the nonlinear algebraic solver
(default <cite>newton_krylov</cite>) to be minimized by the solver.</li>
</ol>
</dd>
</dl>
<p>Options to the nonlinear solvers can be passed in by **kwargs (keyward
arguments) identical to those available to the nonlinear solver.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">phases</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">hb_time</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">duff_osc</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>                                   <span class="n">omega</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.rfft_to_fft">
<code class="descclassname">har_bal.</code><code class="descname">rfft_to_fft</code><span class="sig-paren">(</span><em>X_real</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#rfft_to_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.rfft_to_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch from SciPy real fft form to complex fft form.</p>
</dd></dl>

<dl class="function">
<dt id="har_bal.solmf">
<code class="descclassname">har_bal.</code><code class="descname">solmf</code><span class="sig-paren">(</span><em>x</em>, <em>v</em>, <em>M</em>, <em>C</em>, <em>K</em>, <em>F</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#solmf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.solmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return acceleration of second order linear matrix system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, v, F</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last"><span class="math notranslate nohighlight">\(n\times 1\)</span> arrays of current displacement, velocity, and Force.</p>
</dd>
<dt><strong>M, C, K</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Mass, damping, and stiffness matrices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last"><span class="math notranslate nohighlight">\(n\\times 1\)</span> acceleration vector</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">solmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">    [[-0.95]</span>
<span class="go">     [ 1.6 ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.time_history">
<code class="descclassname">har_bal.</code><code class="descname">time_history</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>num_time_points=200</em>, <em>realify=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#time_history"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.time_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate refined time history from harmonic balance solution.</p>
<p>Harmonic balance solutions presume a limited number of harmonics in the
solution. The result is that the time history is usually a very limited
number of values. Plotting these results implies that the solution isn’t
actually a continuous one. This function fills in the gaps using the
harmonics obtained in the solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>t: array_like</strong></dt>
<dd><p class="first last">1 x m array where m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>x: array_like</strong></dt>
<dd><p class="first last">n x m array where m is the number of equations and m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>realify: boolean</strong></dt>
<dd><p class="first last">Force the returned results to be real.</p>
</dd>
<dt><strong>num_time_points: int</strong></dt>
<dd><p class="first last">number of points desired in the “smooth” time history.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t: array_like</strong></dt>
<dd><p class="first last">1 x num_time_points array.</p>
</dd>
<dt><strong>x: array_like</strong></dt>
<dd><p class="first last">n x num_time_points array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The implication of this function is that the higher harmonics that
were not determined in the solution are zero. This is indeed the assumption
made when setting up the harmonic balance solution. Whether this is a valid
assumption is something that the user must judge when obtaining the
solution.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.34996499</span><span class="p">,</span>  <span class="mf">1.36053998</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11828552</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.991993</span>  <span class="p">,</span> <span class="mf">5.98398601</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_full</span><span class="p">,</span> <span class="n">x_full</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">time_history</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="har_bal.time_history_r">
<code class="descclassname">har_bal.</code><code class="descname">time_history_r</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>num_time_points=200</em>, <em>realify=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/har_bal.html#time_history_r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#har_bal.time_history_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate refined time history from harmonic balance solution.</p>
<p>Harmonic balance solutions presume a limited number of harmonics in the
solution. The result is that the time history is usually a very limited
number of values. Plotting these results implies that the solution isn’t
actually a continuous one. This function fills in the gaps using the
harmonics obtained in the solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>t: array_like</strong></dt>
<dd><p class="first last">1 x m array where m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>x: array_like</strong></dt>
<dd><p class="first last">n x m array where m is the number of equations and m is the number of
values representing the repeating solution.</p>
</dd>
<dt><strong>realify: boolean</strong></dt>
<dd><p class="first last">Force the returned results to be real.</p>
</dd>
<dt><strong>num_time_points: int</strong></dt>
<dd><p class="first last">number of points desired in the “smooth” time history.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t: array_like</strong></dt>
<dd><p class="first last">1 x num_time_points array.</p>
</dd>
<dt><strong>x: array_like</strong></dt>
<dd><p class="first last">n x num_time_points array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The implication of this function is that the higher harmonics that
were not determined in the solution are zero. This is indeed the assumption
made when setting up the harmonic balance solution. Whether this is a valid
assumption is something that the user must judge when obtaining the
solution.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mousai</span> <span class="k">as</span> <span class="nn">ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.34996499</span><span class="p">,</span>  <span class="mf">1.36053998</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11828552</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.991993</span>  <span class="p">,</span> <span class="mf">5.98398601</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_full</span><span class="p">,</span> <span class="n">x_full</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">time_history</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_time_points</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Mousai</a></h1>



<p class="blurb">Harmonic Balance Solvers</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Reference</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/mousai.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Joseph C. Slater.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/reference/mousai.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-62100376-5']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>
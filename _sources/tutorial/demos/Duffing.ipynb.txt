{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import scipy as sp\n",
    "import matplotlib.pyplot as plt\n",
    "import mousai as ms\n",
    "from scipy import pi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function hb_so in module mousai.har_bal:\n",
      "\n",
      "hb_so(sdfunc, x0, omega=1, method='newton_krylov', num_harmonics=1, params={}, **kwargs)\n",
      "    Harmonic balance solver for second order ODEs.\n",
      "    \n",
      "    Obtains the solution of a second order differential equation under the\n",
      "    presumption that the solution is harmonic.\n",
      "    \n",
      "    Returns t (time), x (displacement), v (velocity), and a (acceleration)\n",
      "    response of a second order linear ordinary differential\n",
      "    equation defined by\n",
      "    :math:`\\ddot{\\mathbf{x}}=f(\\mathbf{x},\\mathbf{v},\\omega)`.\n",
      "    \n",
      "    Parameters\n",
      "    ----------\n",
      "    sdfunc: str\n",
      "        name of function that returns **column vector** second derivative\n",
      "        given omega and\n",
      "        \\*\\*kwargs\n",
      "    \n",
      "        :math:`\\ddot{\\mathbf{x}}=f(\\mathbf{x},\\mathbf{v},\\omega)`\n",
      "    omega:  float\n",
      "        assumed fundamental response frequency in radians per second.\n",
      "    num_harmonics: int\n",
      "        number of harmonics to presume. omega = 0 constant term is always\n",
      "        presumed to exist. Minimum (and default) is 1.\n",
      "    x0: array_like\n",
      "        n x m array where n is the number of equations and m is the number of\n",
      "        values representing the repeating solution.\n",
      "        It is required that :math:`m = 1 + 2 num_{harmonics}`. (we will\n",
      "        generalize allowable default values later.)\n",
      "    method: str\n",
      "        Name of optimization method to be used.\n",
      "    params: dict\n",
      "        Dictionary of parameters needed by sdfunc.\n",
      "    other: any\n",
      "        Other keyword arguments available to nonlinear solvers in\n",
      "        `scipy.optimize.nonlin\n",
      "        <https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html>`_.\n",
      "        See Notes.\n",
      "    \n",
      "    Returns\n",
      "    -------\n",
      "    t, x, e, amps, phases: array_like\n",
      "        time, displacement history (time steps along columns), errors,\n",
      "    amps : float array\n",
      "        amplitudes of displacement (primary harmonic) in column vector format.\n",
      "    phases : float array\n",
      "        amplitudes of displacement (primary harmonic) in column vector format.\n",
      "    \n",
      "    Examples\n",
      "    --------\n",
      "    >>> import mousai as ms\n",
      "    >>> t, x, e, amps, phases = ms.hb_so('duff_osc', sp.array([[0,1,-1]]), .7)\n",
      "    \n",
      "    Notes\n",
      "    ------\n",
      "    Calls a linear algebra function from\n",
      "    `scipy.optimize.nonlin\n",
      "    <https://docs.scipy.org/doc/scipy/reference/optimize.nonlin.html>`_ with\n",
      "    ``newton_krylov`` as the default.\n",
      "    \n",
      "    Needs quasi-linear estimator for starting point.\n",
      "    \n",
      "    Should gently \"walk\" solution up to get to nonlinearities.\n",
      "    \n",
      "    Algorithm:\n",
      "        1. calls `hb_so_err` with x as the variable to solve for.\n",
      "        2. `hb_so_err` uses a Fourier representation of x to obtain velocities\n",
      "           (after an inverse fft) then calls `sdfunc` to determine\n",
      "           accelerations.\n",
      "        3. Accelerations are also obtained using a Fourier representation of x\n",
      "        4. Error in the accelerations are the functional error used by the\n",
      "           nonlinear algebraic solver (default ``newton_krylov``) to be\n",
      "           minimized by the solver.\n",
      "    \n",
      "    Options to the nonlinear solvers can be passed in by \\*\\*kwargs.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(ms.hb_so)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "sp.linspace?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "omega = sp.linspace(0,2,201)+1/200"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "t, x, e, amps, phases = ms.hb_so('duff_osc', sp.array([[0,1,-1]]), .7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.4652054368868992"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "amps[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "amp = sp.zeros_like(omega)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [],
   "source": [
    "def duff_osc2(x, v, params):\n",
    "    # print('duff osc')\n",
    "    # print(reduced_kwargs)\n",
    "    omega = params['omega']\n",
    "    t = params['cur_time']\n",
    "    '''print('t=',t)\n",
    "    print('x = ', x)\n",
    "    print('v = ', v)'''\n",
    "    return -x-.000*x**3-.01*v+sin(omega*t)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "'duff_osc2'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-132-98ae0082dad9>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfreq\u001b[0m \u001b[0;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0momega\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;31m#print(i,freq,x)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m     \u001b[0mt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mamps\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mphases\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhb_so\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'duff_osc2'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfreq\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;31m#, callback = resid)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m     \u001b[0mamp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mi\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mamps\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0momega\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mamp\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/jslater/Documents/python-dev/mousai/mousai/har_bal.py\u001b[0m in \u001b[0;36mhb_so\u001b[0;34m(sdfunc, x0, omega, method, num_harmonics, params, **kwargs)\u001b[0m\n\u001b[1;32m    173\u001b[0m         \u001b[0me\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0maccel_from_deriv\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0maccel\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    174\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 175\u001b[0;31m     \u001b[0mx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mglobals\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mmethod\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhb_so_err\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    176\u001b[0m     \u001b[0;31m# v = harmonic_deriv(omega, x)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    177\u001b[0m     \u001b[0;31m# a = harmonic_deriv(omega, v)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/jslater/anaconda/lib/python3.6/site-packages/scipy/optimize/nonlin.py\u001b[0m in \u001b[0;36mnewton_krylov\u001b[0;34m(F, xin, iter, rdiff, method, inner_maxiter, inner_M, outer_k, verbose, maxiter, f_tol, f_rtol, x_tol, x_rtol, tol_norm, line_search, callback, **kw)\u001b[0m\n",
      "\u001b[0;32m/Users/jslater/anaconda/lib/python3.6/site-packages/scipy/optimize/nonlin.py\u001b[0m in \u001b[0;36mnonlin_solve\u001b[0;34m(F, x0, jacobian, iter, verbose, maxiter, f_tol, f_rtol, x_tol, x_rtol, tol_norm, line_search, callback, full_output, raise_exception)\u001b[0m\n\u001b[1;32m    274\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    275\u001b[0m     \u001b[0mdx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minf\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 276\u001b[0;31m     \u001b[0mFx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    277\u001b[0m     \u001b[0mFx_norm\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnorm\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mFx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    278\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/jslater/anaconda/lib/python3.6/site-packages/scipy/optimize/nonlin.py\u001b[0m in \u001b[0;36m<lambda>\u001b[0;34m(z)\u001b[0m\n\u001b[1;32m    270\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    271\u001b[0m     \u001b[0mx0\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_as_inexact\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 272\u001b[0;31m     \u001b[0mfunc\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mlambda\u001b[0m \u001b[0mz\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0m_as_inexact\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mF\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_array_like\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mz\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    273\u001b[0m     \u001b[0mx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    274\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/jslater/Documents/python-dev/mousai/mousai/har_bal.py\u001b[0m in \u001b[0;36mhb_so_err\u001b[0;34m(x)\u001b[0m\n\u001b[1;32m    168\u001b[0m             \u001b[0mparams\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'cur_time'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtime\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mi\u001b[0m\u001b[0;34m]\u001b[0m  \u001b[0;31m# loops\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    169\u001b[0m             \u001b[0;31m# Note that everything in params can be accessed within `function`.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 170\u001b[0;31m             accel_from_deriv[:, i] = globals()[function](x[:, i], vel[:, i],\n\u001b[0m\u001b[1;32m    171\u001b[0m                                                          params)\n\u001b[1;32m    172\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: 'duff_osc2'"
     ]
    }
   ],
   "source": [
    "omega = sp.linspace(0,3,200)+1/200\n",
    "amp = sp.zeros_like(omega)\n",
    "x = sp.array([[0,1,-1]])\n",
    "for i, freq in enumerate(omega):\n",
    "    #print(i,freq,x)\n",
    "    t, x, e, amps, phases = ms.hb_so('duff_osc2', x, freq)#, callback = resid)\n",
    "    amp[i]=amps[0]\n",
    "plt.plot(omega, amp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<function __main__.duff_osc2>"
      ]
     },
     "execution_count": 133,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "globals()['duff_osc2']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x11dc15ba8>]"
      ]
     },
     "execution_count": 130,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x11daa9710>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "omegal = sp.arange(3,1.295,-1/200)+1/200\n",
    "ampl = sp.zeros_like(omegal)\n",
    "x = sp.array([[0,-1,1]])\n",
    "for i, freq in enumerate(omegal):\n",
    "    #print(i,freq,x, \"freq:\",freq, phases)\n",
    "    t, x, e, amps, phases = ms.hb_so('duff_osc', x, freq)#, f_tol = 1e-10)#, callback = resid)\n",
    "    ampl[i]=amps[0]\n",
    "plt.plot(omegal, ampl)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x11bb11f98>]"
      ]
     },
     "execution_count": 127,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXEAAAD7CAYAAACc26SuAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz\nAAALEgAACxIB0t1+/AAAH39JREFUeJzt3Xl8VNXdx/HPmWwkBBISIpsECKIoghgiins1Ku6KINq6\no8HWLrbPo9b26W5bxdqqta2NSxe1FcEdFSWiVbQuASt1YY0sypYEEpKQdeY8f9wJhBhIMpnJnTvz\nfb9e85q7TJjfJZlvbs499xxjrUVERLzJ53YBIiISOoW4iIiHKcRFRDxMIS4i4mEKcRERD1OIi4h4\nmEJcRMTDFOIiIh6mEBcR8bDErrzIGJNvrV3WZr0ouDjaWnvL/r524MCBduTIkaFXKCISh5YuXVph\nrc3p7HWdhrgxphD4MzC6zXqJtbbMGDPPGFNorS3Z19ePHDmS0tLSbpQuIiLGmPVdeV2nzSnBgC5r\nsykPKAwulwXXRUTEBV1qTmnLWlvcZjUfmBu+ckREpDtCvrBpjMkHlrVtKxcRkd7Vk94phfu6qGmM\nKTLGlBpjSsvLy3vwFiIisj8hhbgxpshaOye4XNh+v7W22FpbYK0tyMnp9OKqiIiEqNMQN8ZMBwqC\nz62hfYcxZq0xZkekCxQRkX3r9MKmtXY+ML/NegkwIJJFiYh4XsAPvoSIv43u2BQRCbcd6+HhM+Cj\nJyP+Vt3uYigiIvvx6fPw7A1gLfiSIv52CnERkXBoboBFP4L3imFoPkx/GLJGRfxtFeIiIj1VuRbm\nXQVblsOUb8KpP4HE5F55a4W4iEhPLJ8HC26EhCS4dC4cMrVX314hLiISiqZd8NLN8MEjkDsFLnoQ\nMg7s9TIU4iIi3bXtU6f5pHwlnPC/cPKtkOBOnCrERUS6ylrnzPvFmyElHS5/Ckaf4mpJCnERka5o\nrIEF34X/zoNRJ8G0B6DfILerUoiLiHRq039g/tWwYx2c8n9w/Pd65W7MrlCIi4jsi7Xw3gPwyg8h\nbSBc9QKMONbtqvaiEBcR6Uj9Dnj2m7BiAYw5Ay74E/TNdruqL1GIi4i0t/F9mH8N1GyG038JU24A\nY9yuqkMKcRGRVoEA/Ps+ePVn0H8YXPMyHDjJ7ar2SyEuIgKwazs883VYtRAOPRfOuw9SM92uqlMK\ncRGRDe86zSd12+DMO2HydVHbfNKeQlxE4lcgAP/+PZT8DDKHw6xXYOiRblfVLQpxEYlPdZXwzPWw\n+hU47Hw47/fQJ8PtqrpNIS4i8WfDO8Hmk3I46zdw1LWeaT5pTyEuIvEjEIC374FXfwGZuTBrEQyd\n6HZVPaIQF5H4UFcJT8+GNYvgsAvgvHs92XzSnkJcRGLf+n87zSe7KuDsu6BglmebT9pTiItI7AoE\n4K27YfFtMGAEXFsCQ45wu6qwUoiLSGyqqwg2n5TAuGlw7j3Qp7/bVYWdQlxEYs/6t4PNJ9vhnN/B\npKtjpvmkPV9XXmSMyW+3Pt0YU2iMuTkyZYmIhCAQgDfuhL+eDUlpTvNJwTUxG+DQhRA3xhQC89qs\n5wNYa0uAqvYBLyLiitpyeOwip/173DSY/S8YMsHtqiKu0xAPhnVZm00zgargchlQGIG6RES6bt0S\nuP94WPeW0/Z90YOQ0s/tqnpFKG3imcD2NuvRN0q6iMSHgB/e/C28/ivIyoPL5sPg8W5X1at0YVNE\nvKl2Gzx1HZS9DuNnOBcw4+Tsu61QQrwKyAouZwKV7V9gjCkCigByc3NDLk5EpEOfvQFPXgsN1XDu\nvZB/RUxfvNyfLvVOaWcukBdczgNK2r/AWltsrS2w1hbk5OT0pD4RkT0Cfnj9Dvj7+ZDSH659FSZd\nGbcBDl3rnTIdKAg+Y61dFtxeCFS1rouIRFTtNnh0mtP+PX4GFL0Ogw93uyrXddqcYq2dD8xvt604\nYhWJiLS37i3n5p2GqrhvPmlPFzZFJHq1HTp2wMi47H3SGYW4iESnthMXH3ZBcOad2Bv7pKcU4iIS\nfT5fCvOuhJotnpu4uLcpxEUkelgL7xXDyz+EfkNg1sswbJLbVUU1hbiIRIeGnfDct+CTZ+DgqXDB\nnyAtq/Ovi3MKcRFx35b/whNXwI71cNrPYcq3wBfKbSzxRyEuIu6xFpb9HV68yTnrvuoFGDHF7ao8\nRSEuIu5oqoMF34Plj0PeyTDtQUjXHd7dpRAXkd5XvtJpPilfCSffCifeBL4Et6vyJIW4iPSu5fPg\n+e9AUipc/jSM/orbFXmaQlxEekdzAyz8Piz9C+QeC9Mfhv5D3K7K8xTiIhJ528vgiSthy3I47kY4\n5UeQoPgJB/0vikhkffIcPHsDGB9cOhcOmep2RTFFIS4ikdHSBCU/gXf+CEPzYcZfYcAIt6uKOQpx\nEQm/qo0w/2r4/H2YPBtOvw0Sk92uKiYpxEUkvFYvcua+9Lc4Z9/jLnS7opimEBeR8Aj44fXb4Y05\nMOhwuPjvkD3a7apinkJcRHqurhKenAVlr8HEy+Ds3zj9wCXiFOIi0jMb33fG/q6rcCZuyL/C7Yri\nikJcREJjLbz3ALz8A+g/FGa9AkMnul1V3FGIi0j3NdbC89+Gj56Eg8+EC/8EqQPcriouKcRFpHvK\nV8Lcy6FyNZz6Yzjuuxr720UKcRHpuo+ehGe/tWfwqryT3a4o7inERaRzLU2w6Efw7v0w/Gin/3f/\noW5XJSjERaQz1V/AvKvg8/fgmG8406clJLldlQQpxEVk38peh/mzoKUBpv8FDp/mdkXSTkghboyZ\nDlQBedba4vCWJCKuCwRgyV3w2q9g4MFw8SOQc7DbVUkHuh3ixph8oMxau8wYU2iMybfWLotAbSLi\nhvod8NRsWP0yHD4dzr0HUtLdrkr2IdTmlDuA03DOxEvCWI+IuGnTB87clzs3w1m/gaOuBWPcrkr2\no9udO4Nn3WXGmB3A9vCXJCK9zlpY+ld46AynKeWahTD5OgW4B3Q7xI0xmTjt4b8GHjDG5HXwmiJj\nTKkxprS8vDwMZYpIxDTtgme+4UxePPI4mP0GHFjgdlXSRaE0pxQBv7bWVhljyoDpwJy2Lwhe7CwG\nKCgosD2uUkQiY/tnzt2XWz+Ck25xHr4Et6uSbuhRF0Nr7XxjTFG4ihGRXrR6kTN8LMBXn4CDT3e3\nHglJt0PcWjvHGHNz8Cw8S10MRTwmEIA37oTXf+1M3jDzEcga5XZVEqKQzsSttXM6f5WIRJ36Knh6\nNqxaCBMugXN+B8lpblclPaA7NkXixdaPYe5lULUBzrxTvU9ihEJcJB78dz489y1I6Q9XvQC5x7hd\nkYSJQlwklvmbYdGP4Z0/Qu4UmPE36DfI7aokjBTiIrGqZivMvxrWvwVHfx1O/4VGH4xBCnGRWLTh\nXWfy4voqmPYgTJjhdkUSIQpxkVhiLbz/ICy8FTIOhGtLYPDhblclEaQQF4kVzfWw4Lvw4T9hzBkw\n7c+avDgOKMRFYsGOdU73wS0fwck/gBNv0uTFcUIhLuJ1q0uCt89b3T4fhxTiIl4VCMCbd8Frv4RB\n44K3z39pUFGJcQpxES9qqIanr4eVL8KEmXDO3bp9Pk4pxEW8pnwVPP5V2PEZnDkHJhfp9vk4phAX\n8ZKVL8GT10FiClzxnDOJg8Q1hbiIF+wePvZXMGQiXPKY0w9c4p5CXCTaNeyEZ74OKxbAEZc6w8cm\npbpdlUQJhbhINKtY47R/V66BqbfD0der/Vv2ohAXiVarXoEnr4WERLjiGRh1otsVSRRSiItEG2ud\n/t+Lb4PB453278xct6uSKKUQF4kmjbVO+/enz8H4GXDuver/LfulEBeJFtvL4PGvQfkKOP02mPJN\ntX9LpxTiItFgTQnMvwaMDy57CkZ/xe2KxCMU4iJushbeuhte/TkccJjT/j1gpNtViYcoxEXc0lQH\nz94AHz8N46bB+fdBcl+3qxKPUYiLuGHHOqf9e9snUPgzOO47av+WkCjERXrbuiXOBA42AF+bBwcV\nul2ReFhIIW6MyQfyAKy188NakUgsW/pXeOF/nHG/L30cske7XZF4XKjzN90aDO+8YKCLyP74W+Cl\n78Pz34G8k50JjBXgEgbdPhM3xkwH3gew1s4Je0UisaahGuZdDWtfhWO+Aaf9wrmVXiQMQvlJOgp2\nN6kUKshF9qNyLfzzEudGnnPvhUlXul2RxJhQm1MqrbXLYPeZ+V6MMUXGmFJjTGl5eXmPChTxrM/e\ngAdOgboKuOJZBbhERCghXgmUBZerCJ6Zt2WtLbbWFlhrC3JycnpSn4g3lT4Mj1wI/QbDdYth5PFu\nVyQxKpQQn0+wZwqQSbB9XERwLmC+eDMs+C6MPgVmLYKsUW5XJTGs223i1toyY0xVsBklW23iIkH1\nO5wLmGWvOYNXnfZz8CW4XZXEuJAukVtri4OL6iMuAs4MPP+cCTvWw3n3Qf7lblckcUL9nER6qux1\neOIK8CU6FzA1A730olB7p4gIwHsPwCPToN/Q4AVMBbj0Lp2Ji4TC3wwLvw/vPwgHT4VpD0Cf/m5X\nJXFIIS7SXfU74Ikr4bN/wbHfhsKf6gKmuEYhLtIdFavhHzOhagOc/0c48mtuVyRxTiEu0lVrF8MT\nV0FCEly1AHKPcbsiEV3YFOmUtfBuMTw6HTIOdC5gKsAlSuhMXGR//M3w0s3ObfSHnAXTiiGln9tV\nieymEBfZl13bnf7f696E426EU38CPv3xKtFFIS7SkfKVzgXMnV/ABffDxEvdrkikQwpxkfbWlDhj\noCSmwJULIPdotysS2Sf9bSjSylp450/w2AzIHBG8gKkAl+imM3ERgJYmePF/YdnfYOw5cOGfISXd\n7apEOqUQF9m1HeZeDuuXwPHfg1N+pAuY4hkKcYlv21Y4Q8ju3OyMfzLhYrcrEukWhbjEr9WLYP41\nkNgHrnoBhn9ppkGRqKe/GSX+WAv//gP842IYMAKKXlOAi2fpTFziS0sTvPA9+OAROPRc5wJmcl+3\nqxIJmUJc4kddhXMBc8PbcOJNcPIPdAFTPE8hLvFh6yfOBcyarXDRQzB+utsViYSFQlxi36qXnQuY\nyX3h6pfgwEluVyQSNvpbUmKXtfDWvc4YKNmj4brXFOASc3QmLrGppREWfA/+8ygcdj5c8CddwJSY\npBCX2FNbDk9cDhv+DSfdAid9XxcwJWYpxCW2bP0Y/nEJ1G2D6Q/D4Re5XZFIRPXo9MQYc3O4ChHp\nsZUvwUOng78Jrn5RAS5xIeQQN8YUAqeFsRaR0FgLb94F/7wUsg9y7sAcpguYEh/UnCLe1lwPz34T\nPprvnHmf/wdISnW7KpFeE9KZuDEm31pbEu5iRLpl5yb4y5nw0ZNw6o+dm3gU4BJnQj0Tz9rfTmNM\nEVAEkJubG+JbiOzH56Xw+NegqRYu+QeMPcvtikRc0e0z8a6chVtri621BdbagpycnNCrE+nIh3Ph\nL2c5c2DOWqQAl7gWypl4njEmD+dsPCsY6svCXJfIlwX8UPJTePteGHkCzPgb9M12uyoRV3U7xK21\n82F3k0lm2CsS6UjDTnjyWlj9MhTMgjPvgIQkt6sScV3IvVOstcVAcRhrEelY5Vqn++D2tXD2XXDU\ntW5XJBI11MVQotvaxTDvajAGLn8aRp3odkUiUUUDSkh0shaW3A2PXgT9hzojECrARb5EZ+ISfRpr\n4dkb4JNnYNyFcN59kJLudlUiUUkhLtGlci3MvQzKV8BpP4djv+00pYhIhxTiEj1WvQJPXQvGB5c9\nCaNPcbsikainEBf3BQLOAFav/RIGHw4zH4UBI92uSsQTFOLiroad8MzXYcUCGH8xnHsPJKe5XZWI\nZyjExT3lq2Du15x28Km3w9HXq/1bpJsU4uKOFS/AU7Od8U+ueBZGneB2RSKepBCX3uVvgddugyW/\ng6FHOu3fGQe6XZWIZynEpffUbIH5s2D9Eph0FUy9A5L6uF2ViKcpxKV3fPYmzL8GGmvgwj/DEZe4\nXZFITFCIS2QFAvDW3bD4F5A12mn/HnSY21WJxAyFuETOru1O98FVC2HcNDjvXkjp53ZVIjFFIS6R\n8cUyeOJKqNkMZ94Jk69T90GRCFCIS3hZC6UPwcJbIX0QXLMQDixwuyqRmKUQl/Cpr4Lnv+OMPnjQ\naTCtGNL2O6e2iPSQQlzCY+N7TvfBmk1w6k/guBvBp+HqRSJNIS49E/A7N+689ivIGAZXL4ThR7ld\nlUjcUIhL6HZuhqeL4LM3nN4n594NfTLcrkokrijEJTQrXoDnvgXN9c7MO0dept4nIi5QiEv3NFQ7\nPU/+8xgMHg8XPQQ5h7hdlUjcUohL1332BjzzDdj5BZx4E5x4MyQmu12VSFxTiEvnmnbBqz+Dd++H\n7INg1iL1/RaJEgpx2b+N7zln35WrYfJsKPypZt4RiSIKcelYQzW8+nN4/yHoP8wZuCrvZLerEpF2\nQgpxY0xRcHG0tfaWMNYj0eDT5+HFm5zxv4++Hk75oQauEolS3Q5xY0whUGKtLTPGzDPGFFprSyJQ\nm/S27Z/Byz+ElS/AoPFwyWMwbJLbVYnIfoRyJp4XfBQDZcFl8bLGWljyW3j7PvAlQOHPYMoNkJDk\ndmUi0oluh7i1trjNaj4wN3zlSK8KBGD5XCj5KdRugQkznQuX/Ye6XJiIdFXIFzaNMfnAMmvtsg72\nFQFFALm5uaFXJ5FhLawpcWbb2fyh02Qy89GoH/Nke10TWX3VL12krZ4MM1e4r4ua1tpia22BtbYg\nJyenB28hYffZm/DwVHhsOtTvcOa7nFUS9QF+d8kqjrt9MQ3NfrdLEYkqIfdOsdbOCS7rwma0sxbW\nLYE3fwNlr0O/IXD2XXDkFZ6543L8sAzqm/2UrtvB8WMGul2OSNQItXfKHcaYW4AsYEbYq5LwCPid\n7oJv3QOblkHaQDj9l3DULEhKdbu6bjkmL5vkBB+LPtmiEBdpI5QLmyXAgAjUIuHSsNO5YPnOH2F7\nGQwYBWf/FiZ+1XPh3apvSiKnjxvEM//ZxK1nHUqfpAS3SxKJCrpjM5ZsXg6lD8N/50FTLQw9Emb8\nDQ491+k66HGXTs5lwfLNLPxoCxccOcztckSigkLc63Ztd+a0/OAx+KIUEvvA4RdBwTVOr5MYGuN7\nSl42o3P68vvFqzlnwhASEzT9m4hC3IuaG2DVQueMe9XLEGiGgYfA1NvhiEsgNTZbu3w+w01njOX6\nR5fy+PsbueyYEW6XJOI6hbhXNOyENYvg0wWwehE01UD6IJhcBBMuhiFHxNRZ976cMW4Qx+RlcftL\nK/jK2AMYlunNNn6RcFGIRytrnYuSaxc7Z91l/3LOuNMGwrjznSaTUSfFRFt3dxhjuHP6EUy9+w1u\neGwZjxcdo4ucEtcU4tGkthw2vO0E99rFULXB2T5gFBw9G8aeA8Mnx11wtzc8K427Lp7I9Y8u5ab5\ny7ln5kR8vtj/K0SkIwpxt1gLFath4zuwIfjYvtbZl9wP8k6CY78No0+BrLy4aCrpjqmHD+aWqWO5\nY+EKUhJ93HHRBBIU5BKHFOK9IRBwmka2fOh0A9yyHDb9B+q3O/tTsyB3Cky60nkeeqRGEOyC60/K\no6klwO9KVlFd38zvZk4kPUU/0hJf9BMfToEAVG9wzrArVjmPbStg60dOv20AXxIcMBbGngXDj3ZC\nO/sgnWmHwBjDdwrH0D81kdte+JQL/vAW9182iYMOSHe7NJFeY6y1EX2DgoICW1paGtH36FUN1U5b\nddXG4PMGqFoPO9ZB5Rpoadjz2tQBkDMWBo+HwRNgyATIOdQz45V4ydtrK/jmPz6grrGFm844hKuP\nG6XmFfE0Y8xSa22nM5IrxAH8LdC4E+oqoHZr8LHNea4rd55rtjpn2Q3Ve39tYipk5sKAETDw4L0f\nfbPdOZ44tXVnAz946r+8umIbEw7M4P/OPozJo7LcLkskJN4PcX8L+BudQZwCLWADznPADza4LRDc\n1lIPzW0eLQ3QvGvvbY07ob7KCeGG1udqZ1tTTcc1+JIg/YDgYxBkDIfM4U5oZ+ZCRi70HaimkChi\nreW5Dzdx+0sr2FzdwBnjBvHtU8cwbmiG26WJdEtXQzx628SXz4VnvxG+fy85HfpkQp8MSM10Qrjt\nep8Mpw92a2CnH+A0hyigPcUYw/kTh3H6YYN5aEkZ9/+rjJc/3soJYwby9ZNGM2V0NkbfU4kh0Xsm\nvvUT5w5FkwC+RKdvtPG1WW7d7nOaNJLaPHavp0FSH2c8kTjvWx2vquubeezd9Ty8ZB0VtY3k5fTl\n4oLhTMsfxgH9+rhdnsg+eb85RSSMGpr9PP/hJp4o3cj763aQ4DOcOGYgZx4+hMLDBmnaN4k6CnGR\nfVhbXssTpRtZ8OFmvqiqx2fg6FHZFB42iBPGDGTMAelqchHXKcRFOmGt5eNNO1n40RYWfryFNduc\nvvw5/VI4/qCBHDs6m8mjssjNSlOoS69TiIt008btu3h7bQVL1lTy9poKKuuaAMjqm8zE4ZkcOTyT\nI3MHMGF4Bv376I5aiSzv904R6WXDs9KYmZXLzKNyCQQsq7bVsGx9FR9s2MEHG6tYvGLb7tcOy0xl\n7OB+HBJ8HDqkP6MG9iVJE1VIL1OIi3TA5zOMHdyfsYP789WjcwGnp8vyz6tY/nk1K7bUsHLLTv61\nqpyWgPPXbHKCj9zsNEZm92VkdhojB/ZlZHZfRmSnMTQzVXeQSkQoxEW6KCM1iRPG5HDCmJzd2xpb\n/JSV17FySw0rttRQVl7L+spdvLm6nMaWwO7XJSf4ODArlWGZqQzJ6MOQjFSGZu793FeDd0kI9FMj\n0gMpiQkcOqQ/hw7pv9f2QMCytaaBdRW7WFdZx7rKOtZX7GJzdT0rttRQUdtI+8tR/fskMjQzlZx+\nKQxMT2FgejLZ6XuWBwaXs9OT1WwjuynERSLA5zMMyUhlSEYqU0Z/eQydppYAW3c2sKmqns3VDWyq\nrmdLdQObqhqoqG3ks4o6KmobaWgOdPCvQ2ZaEtl9k8lITSIzLZnM1CT6pyaRmZYU3JZEZmryXtsy\nUpMU/jFIIS7iguREH8Oz0hielbbP11hrqWvyU1nbSEVtI+U1TVTUNlJZG3yua6S6vpltNQ2s2lpD\ndX0zNQ0t+33f1KQE0vskkp6SSN+UBNJTWpcTO1xO79O6nkB6ShJpyQmkJPlITUogNSmBRP1ScJ1C\nXCRKGWN2h+mI7L5d+poWf4CdDS1U1zdTtauJ6vrm3Y+qXc3UNDRT2+intrGFusYWahta2FTVsGe9\nsWWvtvzOJCUY+gQDPTXZeW673ifJt2d99zZnOSXJR3KCj+REHymJznNyQoLzvNe2NsvBdf3y2COk\nEDfGTAeqgHxr7ZzwliQioUpM8JHVNzk4jEDXgr+9Zn+AusYWahpaqGtq2bPc6Ke+2Xk0NLVZDj7q\nd28L0NDkp7ym0dnebn8gDLem+Ay7Az05MYGUxC8HfXKiE/ZJPkNigmmz7CMpwZDgMyT6nOW2+xIT\nDEk+Hwk+s3tfos+QFNyX6HPWExOC29r8m4m+1tc4+zLSkiJ+T0G3Q9wYkw9grS0xxuQZY/KttcvC\nX5qIuCEpwee0s6eFfzwZay1N/gANTQEaW/w0tgRo8gdobHaem1qCD7+fppaAs3+frwns9ZrGFv9e\n25taAtQ1+WnxB2jxW5oDznOLP0BzwHluCVhnWyBAsz/8Nz7eWDiGGwsPDvu/21YoZ+IzgUXB5TKg\nEFCIi0injDGkJCaQkpgARNddr9Za/AFLS8DS7A/gD1iagwHf4ne2fWlfm22tvwxafzE0+wNf6rUU\nCaGEeCawvc26pq8REc8zprXZBfokeWfo6ohcHTDGFBljSo0xpeXl5ZF4CxERIbQQrwJaJy7MBCrb\nv8BaW2ytLbDWFuTk5LTfLSIiYRJKiM8F8oLLeUBJ+MoREZHu6HaIt/ZEMcYUAlXqmSIi4p6Q+olb\na4vDXYiIiHSfbnsSEfEwhbiIiIcpxEVEPCzic2waY8qB9SF++UCgIozluClWjiVWjgN0LNEqVo6l\np8cxwlrbaR/tiId4TxhjSrsyUagXxMqxxMpxgI4lWsXKsfTWcag5RUTEwxTiIiIeFu0hHkv90WPl\nWGLlOEDHEq1i5Vh65Tiiuk1cRET2L9rPxMVlrZOA7GPfdGNMoTHm5t6sKVSdHMsdweei3qtIpOei\nJsQ7CwSvBEYXjsMzYREcH2fePvbtnuEJqNpfQEaD/R1LUJExZi3ORCdRKzjMc1Hrz1EH+z3xOYEu\nHYunPivBR69/X6IixDsLBK8ERhfr9ERYwO7j2FedM3GGJYY9MzxFrU6OBeA6a+3o4OuiUvAXUUlw\n7KK84Hrb/Z74nEDnxxLkic9KsPYZwf/3/N7Or6gIcToPBK8ERlfqjPqw6KJYm+EpzwNnsHns+Zkq\nY8+Q0K288jmBzo8FPPJZsdaWWGtnB1fzOhjZNaLfl2gJ8c4CwSuB0ZU6vRAWccdaOycYFtn7OCt0\nXXCyldYeD/lAabuXeOVz0pVjAY99VoJ1zu5gV0S/L9ES4nHDC2HRRZ3O8OQVwXbZ6cHVSjo+K4wa\nwT/Hl8XCWP77OxavfVastXOA2caYzN5832gJ8c4CwSuBsd86vRYWHWnzA+r5GZ7aHEspe+ofTcdn\nhdGk0Fp7SwfbvfI5aavDY/HSZ8UY07YdvAxofyE2ot+XaAnxDgPBg4HR2XF4KiyCH6KCNh8mgFfB\nezM8deFYLg7uWxvNx2KMKQqe8bX+33vxcwJ0eixe+qwUsndIl0HvfV+i5mafYDeiMpwLA8XBbUut\ntZP2tT8adfE4tgf3z3GvUvGaNt0kt+OExgxrbYlHPyddPZao/6wEw/ri4Oqk1oucvfV9iZoQFxGR\n7ouW5hQREQmBQlxExMMU4iIiHqYQFxHxMIW4iIiHKcRFRDxMIS4i4mH/Dy3su4Zu5PydAAAAAElF\nTkSuQmCC\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x10dc139e8>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(omegal,ampl)\n",
    "plt.plot(omega,amp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from scipy.optimize import newton_krylov"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function newton_krylov in module scipy.optimize.nonlin:\n",
      "\n",
      "newton_krylov(F, xin, iter=None, rdiff=None, method='lgmres', inner_maxiter=20, inner_M=None, outer_k=10, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)\n",
      "    Find a root of a function, using Krylov approximation for inverse Jacobian.\n",
      "    \n",
      "    This method is suitable for solving large-scale problems.\n",
      "    \n",
      "    Parameters\n",
      "    ----------\n",
      "    F : function(x) -> f\n",
      "        Function whose root to find; should take and return an array-like\n",
      "        object.\n",
      "    x0 : array_like\n",
      "        Initial guess for the solution\n",
      "    rdiff : float, optional\n",
      "        Relative step size to use in numerical differentiation.\n",
      "    method : {'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function\n",
      "        Krylov method to use to approximate the Jacobian.\n",
      "        Can be a string, or a function implementing the same interface as\n",
      "        the iterative solvers in `scipy.sparse.linalg`.\n",
      "    \n",
      "        The default is `scipy.sparse.linalg.lgmres`.\n",
      "    inner_M : LinearOperator or InverseJacobian\n",
      "        Preconditioner for the inner Krylov iteration.\n",
      "        Note that you can use also inverse Jacobians as (adaptive)\n",
      "        preconditioners. For example,\n",
      "    \n",
      "        >>> from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian\n",
      "        >>> from scipy.optimize.nonlin import InverseJacobian\n",
      "        >>> jac = BroydenFirst()\n",
      "        >>> kjac = KrylovJacobian(inner_M=InverseJacobian(jac))\n",
      "    \n",
      "        If the preconditioner has a method named 'update', it will be called\n",
      "        as ``update(x, f)`` after each nonlinear step, with ``x`` giving\n",
      "        the current point, and ``f`` the current function value.\n",
      "    inner_tol, inner_maxiter, ...\n",
      "        Parameters to pass on to the \\\"inner\\\" Krylov solver.\n",
      "        See `scipy.sparse.linalg.gmres` for details.\n",
      "    outer_k : int, optional\n",
      "        Size of the subspace kept across LGMRES nonlinear iterations.\n",
      "        See `scipy.sparse.linalg.lgmres` for details.\n",
      "    iter : int, optional\n",
      "        Number of iterations to make. If omitted (default), make as many\n",
      "        as required to meet tolerances.\n",
      "    verbose : bool, optional\n",
      "        Print status to stdout on every iteration.\n",
      "    maxiter : int, optional\n",
      "        Maximum number of iterations to make. If more are needed to\n",
      "        meet convergence, `NoConvergence` is raised.\n",
      "    f_tol : float, optional\n",
      "        Absolute tolerance (in max-norm) for the residual.\n",
      "        If omitted, default is 6e-6.\n",
      "    f_rtol : float, optional\n",
      "        Relative tolerance for the residual. If omitted, not used.\n",
      "    x_tol : float, optional\n",
      "        Absolute minimum step size, as determined from the Jacobian\n",
      "        approximation. If the step size is smaller than this, optimization\n",
      "        is terminated as successful. If omitted, not used.\n",
      "    x_rtol : float, optional\n",
      "        Relative minimum step size. If omitted, not used.\n",
      "    tol_norm : function(vector) -> scalar, optional\n",
      "        Norm to use in convergence check. Default is the maximum norm.\n",
      "    line_search : {None, 'armijo' (default), 'wolfe'}, optional\n",
      "        Which type of a line search to use to determine the step size in the\n",
      "        direction given by the Jacobian approximation. Defaults to 'armijo'.\n",
      "    callback : function, optional\n",
      "        Optional callback function. It is called on every iteration as\n",
      "        ``callback(x, f)`` where `x` is the current solution and `f`\n",
      "        the corresponding residual.\n",
      "    \n",
      "    Returns\n",
      "    -------\n",
      "    sol : ndarray\n",
      "        An array (of similar array type as `x0`) containing the final solution.\n",
      "    \n",
      "    Raises\n",
      "    ------\n",
      "    NoConvergence\n",
      "        When a solution was not found.\n",
      "    \n",
      "    See Also\n",
      "    --------\n",
      "    scipy.sparse.linalg.gmres\n",
      "    scipy.sparse.linalg.lgmres\n",
      "    \n",
      "    Notes\n",
      "    -----\n",
      "    This function implements a Newton-Krylov solver. The basic idea is\n",
      "    to compute the inverse of the Jacobian with an iterative Krylov\n",
      "    method. These methods require only evaluating the Jacobian-vector\n",
      "    products, which are conveniently approximated by a finite difference:\n",
      "    \n",
      "    .. math:: J v \\approx (f(x + \\omega*v/|v|) - f(x)) / \\omega\n",
      "    \n",
      "    Due to the use of iterative matrix inverses, these methods can\n",
      "    deal with large nonlinear problems.\n",
      "    \n",
      "    Scipy's `scipy.sparse.linalg` module offers a selection of Krylov\n",
      "    solvers to choose from. The default here is `lgmres`, which is a\n",
      "    variant of restarted GMRES iteration that reuses some of the\n",
      "    information obtained in the previous Newton steps to invert\n",
      "    Jacobians in subsequent steps.\n",
      "    \n",
      "    For a review on Newton-Krylov methods, see for example [1]_,\n",
      "    and for the LGMRES sparse inverse method, see [2]_.\n",
      "    \n",
      "    References\n",
      "    ----------\n",
      "    .. [1] D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2004).\n",
      "           :doi:`10.1016/j.jcp.2003.08.010`\n",
      "    .. [2] A.H. Baker and E.R. Jessup and T. Manteuffel,\n",
      "           SIAM J. Matrix Anal. Appl. 26, 962 (2005).\n",
      "           :doi:`10.1137/S0895479803422014`\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(newton_krylov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def resid(x,f):\n",
    "    print(f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 1. ,  0.9,  0.8,  0.7,  0.6,  0.5,  0.4,  0.3,  0.2,  0.1])"
      ]
     },
     "execution_count": 104,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sp.arange(1,0,-.1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "hide_input": false,
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
